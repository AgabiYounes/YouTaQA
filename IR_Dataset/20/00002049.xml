  <page>
    <title>Alpha compositing</title>
    <ns>0</ns>
    <id>2049</id>
    <revision>
      <id>939008151</id>
      <parentid>939008060</parentid>
      <timestamp>2020-02-03T19:40:04Z</timestamp>
      <contributor>
        <username>CRau080</username>
        <id>33923477</id>
      </contributor>
      <minor />
      <comment>/* Analytical derivation of the over operator */  ditto as in previous edit.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve">{{merge|Alpha mapping|date=November 2019}}

{{More citations needed|date=May 2010}}

[[Image:Hue alpha falloff.png|thumb|This [[color spectrum]] image's alpha channel falls off to zero at its base, where it is blended with the background color.]]

In [[computer graphics]], '''alpha compositing''' is the process of combining one image with a background to create the appearance of partial or full [[Transparency (graphic)|transparency]]. It is often useful to render [[Picture element|picture elements]] (pixels) in separate passes or layers and then combine the resulting [[2D computer graphics|2D images]] into a single, final image called the [[compositing|composite]]. Compositing is used extensively in [[film]] when combining [[Computer-generated imagery|computer-rendered image]] elements with [[live footage]]. '''Alpha blending''' is also used in 2D computer graphics to put [[rasterized]] foreground elements over a background.

In order to combine the picture elements of the images correctly, it is necessary to keep an associated ''[[matte (filmmaking)|matte]]'' for each element in addition to its color. This matte layer contains the coverage information—the shape of the geometry being drawn—making it possible to distinguish between parts of the image where something was drawn and parts that are empty.

Although the most basic operation of combining two images is to put one over the other, there are many operations, or [[blend modes]], that are used.

==Description==
To store [[Matte (filmmaking)|matte]] information, the concept of an '''alpha channel''' was introduced by [[Alvy Ray Smith]] in the late 1970s and fully developed in a 1984 paper by [[Thomas Porter (Pixar)|Thomas Porter]] and [[Tom Duff]].&lt;ref&gt;{{Cite journal|last=Porter|first=Thomas|author-link=Thomas Porter (Pixar)|last2=Duff|first2=Tom|author-link2=Tom Duff|date=July 1984|title=Compositing Digital Images|url=http://graphics.pixar.com/library/Compositing/paper.pdf|url-status=live|format=[[PDF]]|journal=SIGGRAPH Computer Graphics|language=en|location=New York City, New York|publisher=ACM Press|volume=18|issue=3|pages=253–259|doi=10.1145/800031.808606|isbn=9780897911382|archive-url=https://web.archive.org/web/20110429041428/http://graphics.pixar.com/library/Compositing/paper.pdf|archive-date=2011-04-29|access-date=2019-03-11|via=}}&lt;/ref&gt; In a 2D picture element (pixel), which stores a color for each pixel, additional data is stored in the alpha channel with a value ranging from 0 to 1. A value of 0 means that the pixel is [[transparency and translucency|transparent]] and does not provide any coverage information; i.e. there is no [[Glossary of computer graphics|occlusion]] at the image pixel window because the geometry did not overlap this pixel. A value of 1 means that the pixel is fully occluding because the geometry completely overlaps the pixel window.

=== Straight versus premultiplied ===
If an alpha channel is used in an image, there are two common representations that are available: straight (unassociated) alpha, and premultiplied (associated) alpha.

With straight alpha, the RGB components represent the color of the object or pixel, disregarding its opacity.

With premultiplied alpha, the RGB components represent the emission of the object or pixel, and the alpha represents the occlusion. A more obvious advantage of this is that, in certain situations, it can save a subsequent multiplication (e.g. if the image is used many times during later compositing). However, the most significant advantages of using premultiplied alpha are for correctness and simplicity rather than performance: premultiplied alpha allows correct filtering and blending. In addition, premultiplied alpha allows regions of regular alpha blending and regions with [[Blend modes#Addition|additive blending mode]] to be encoded within the same image, because channel values are usually stored in a fixed-point format which bounds the values to be between 0 and 1.&lt;ref&gt;{{cite web|url=https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BPremultiplied+alpha%5D%5D |title=TomF's Tech Blog - It's only pretending to be a wiki |website=tomforsyth1000.github.io |accessdate=8 May 2018 |url-status=live |archiveurl=https://web.archive.org/web/20171212111056/http://tomforsyth1000.github.io/blog.wiki.html#%5B%5BPremultiplied+alpha%5D%5D |archivedate=12 December 2017}}&lt;/ref&gt;

Assuming that the pixel color is expressed using ''straight'' (non-premultiplied) RGBA [[tuple]]s, a pixel value of (0, 0.7, 0, 0.5) implies a pixel that has 70% of the maximum green intensity and 50% opacity. If the color were fully green, its RGBA would be (0, 1, 0, 0.5).

However, if this pixel uses premultiplied alpha, all of the RGB values (0, 0.7, 0) are multiplied, or scaled for occlusion, by the alpha value 0.5, which is appended to yield (0, 0.35, 0, 0.5). In this case, the 0.35 value for the G channel actually indicates 70% green emission intensity (with 50% occlusion). A pure green emission would be encoded as (0, 0.5, 0, 0.5). Knowing whether a file uses straight or premultiplied alpha is essential to correctly process or composite it, as a different calculation is required. It is also entirely acceptable to have an RGBA triplet express emission with no occlusion, such as (0.4, 0.3, 0.2, 0.0). Fires and flames, glows, flares, and other such phenomena can only be represented using associated / premultiplied alpha.

The only important difference is in the dynamic range of the colour representation in finite precision numerical calculations (which is in all applications): premultiplied alpha has a unique representation for transparent pixels, avoiding the need to choose a &quot;clear color&quot; or resultant artifacts such as edge fringes (see the next paragraphs). In an associated / premultiplied alpha image, the RGB represents the emission amount, while the alpha is occlusion. Premultiplied alpha has some practical advantages over normal alpha blending because [[interpolation]] and [[Filter (signal processing)|filtering]] give correct results.&lt;ref&gt;{{Cite web|url=http://animationmet.com/alpha-compositing/|title=ALPHA COMPOSITING – Animationmet|last=|first=|date=|website=animationmet.com|language=en-US|url-status=live|archive-url=|archive-date=|access-date=2019-09-25}}&lt;/ref&gt;

Ordinary interpolation without premultiplied alpha leads to RGB information leaking out of fully transparent (A=0) regions, even though this RGB information is ideally invisible. When interpolating or filtering images with abrupt borders between transparent and opaque regions, this can result in borders of colors that were not visible in the original image. Errors also occur in areas of semitransparency because the RGB components are not correctly weighted, giving incorrectly high weighting to the color of the more transparent (lower alpha) pixels.

Premultiplication can reduce the available relative precision in the RGB values when using integer or fixed-point representation for the color components, which may cause a noticeable loss of quality if the color information is later brightened or if the alpha channel is removed. In practice, this is not usually noticeable because during typical composition operations, such as OVER, the influence of the low-precision colour information in low-alpha areas on the final output image (after composition) is correspondingly reduced. This loss of precision also makes premultiplied images easier to [[Data compression|compress]] using certain compression schemes, as they do not record the color variations hidden inside transparent regions, and can allocate fewer bits to encode low-alpha areas. The same “limitations” of lower quantisation bit depths such as 8 bit per channel are also present in imagery without alpha, and this argument is problematic as a result.

With the existence of an alpha channel, it is possible to express compositing image operations using a ''compositing algebra''. For example, given two image elements A and B, the most common compositing operation is to combine the images such that A appears in the foreground and B appears in the background. This can be expressed as A '''over''' B. In addition to '''over''', Porter and Duff defined the compositing operators '''in''', '''held out by''' (usually abbreviated '''out'''), '''atop''', and '''xor''' (and the reverse operators '''rover''', '''rin''', '''rout''', and '''ratop''') from a consideration of choices in blending the colors of two pixels when their coverage is, conceptually, overlaid orthogonally:

[[Image:Alpha compositing.svg]]

The '''over''' operator is, in effect, the normal painting operation (see [[Painter's algorithm]]). The '''in''' operator is the alpha compositing equivalent of [[Clipping (computer graphics)|clipping]].

As an example, the '''over''' operator can be accomplished by applying the following formula to each pixel value:

:&lt;math&gt;C_o = \frac{C_a \alpha_a + C_b \alpha_b (1 - \alpha_a)}{\alpha_a + \alpha_b(1 - \alpha_a)}&lt;/math&gt;

where &lt;math&gt;C_o&lt;/math&gt; is the result of the operation, &lt;math&gt;C_a&lt;/math&gt; is the color of the pixel in element A, &lt;math&gt;C_b&lt;/math&gt; is the color of the pixel in element B, and &lt;math&gt;\alpha_a&lt;/math&gt; and &lt;math&gt;\alpha_b&lt;/math&gt; are the alpha of the pixels in elements A and B respectively.  If it is assumed that all color values are premultiplied by their alpha values (&lt;math&gt;c_i = \alpha_i C_i&lt;/math&gt;), we can rewrite the equation for output color as:

:&lt;math&gt;c_o = c_a + c_b(1 - \alpha_a)&lt;/math&gt;
and resulting alpha channel value is
:&lt;math&gt;\alpha_o = \frac{c_o}{C_o} = \alpha_a + \alpha_b(1 - \alpha_a)&lt;/math&gt;

=== Examples of different operations ===
Examples of red overlaid with green, with both colours fully opaque:

&lt;gallery&gt;
File:PorterDuffAdd.png|ADD operation
File:PorterDuffClear.png|CLEAR operation
File:PorterDuffMultiply.png|MULTIPLY operation
File:PorterDuffOverlay.png|OVERLAY operation
&lt;/gallery&gt;

==Analytical derivation of the over operator==

Porter and Duff gave a geometric interpretation of the alpha compositing formula by studying orthogonal coverages. Another derivation of the formula, based on a physical [[reflectance]]/[[transmittance]] model, can be found in a 1981 paper by Bruce A. Wallace.&lt;ref&gt;{{cite journal |last=Wallace |first=Bruce A. |date=1981 |title=Merging and transformation of raster images for cartoon animation |journal=SIGGRAPH Computer Graphics |location=New York City, New York |publisher=ACM Press |volume=15 |issue=3 |pages=[https://archive.org/details/siggraph81confer15sigg/page/253 253–262] |citeseerx=10.1.1.141.7875 |doi=10.1145/800224.806813 |isbn=0-89791-045-1 |via= |url-access=registration |url=https://archive.org/details/siggraph81confer15sigg/page/253 }}&lt;/ref&gt;


A third approach is found by starting out with two very simple assumptions. For simplicity, we shall here use the shorthand notation &lt;math&gt;a \odot b&lt;/math&gt; for representing the '''over''' operator.

The first assumption is that in the case where the background is opaque (i.e. &lt;math&gt;\alpha_b = 1&lt;/math&gt;), the over operator represents the [[convex combination]] of &lt;math&gt;a&lt;/math&gt; and &lt;math&gt;b&lt;/math&gt;:

:&lt;math&gt;C_o = \alpha_a C_a + (1 - \alpha_a) C_b&lt;/math&gt;

The second assumption is that the operator must respect the associative rule:

:&lt;math&gt;(a \odot b) \odot c = a \odot (b \odot c)&lt;/math&gt;

Now, let us assume that &lt;math&gt;a&lt;/math&gt; and &lt;math&gt;b&lt;/math&gt; have variable transparencies, whereas &lt;math&gt;c&lt;/math&gt; is opaque. We're interested in finding

:&lt;math&gt;o = a \odot b.&lt;/math&gt;

We know from the associative rule that the following must be true:

:&lt;math&gt;o \odot c = a \odot (b \odot c)&lt;/math&gt;

We know that &lt;math&gt;c&lt;/math&gt; is opaque and thus follows that &lt;math&gt;b \odot c&lt;/math&gt; is opaque, so in the above equation, each &lt;math&gt;\odot&lt;/math&gt; operator can be written as a convex combination:

:&lt;math&gt;
\begin{align}
  \alpha_o C_o + (1 - \alpha_o) C_c &amp;= \alpha_a C_a + (1 - \alpha_a) (\alpha_b C_b + (1 - \alpha_b) C_c) \\[5pt]
  &amp;= [\alpha_a C_a + (1 - \alpha_a) \alpha_b C_b] + (1 - \alpha_a) (1 - \alpha_b) C_c
\end{align}
&lt;/math&gt;

Hence we see that this represents an equation of the form &lt;math&gt;X_0 + Y_0 C_c = X_1 + Y_1 C_c&lt;/math&gt;. By setting &lt;math&gt;X_0 = X_1&lt;/math&gt; and &lt;math&gt;Y_0 = Y_1&lt;/math&gt; we get

:&lt;math&gt;
\begin{align}
  \alpha_o &amp;= 1 - (1 - \alpha_a) (1 - \alpha_b),\\[5pt]
  C_o &amp;= \frac{\alpha_a C_a + (1 - \alpha_a)\alpha_b C_b}{\alpha_o},
\end{align}
&lt;/math&gt;
which means that we have analytically derived a formula for the output alpha and the output color of &lt;math&gt;a \odot b&lt;/math&gt;.

An even more compact representation is given by noticing that &lt;math&gt;(1 - \alpha_a)\alpha_b = \alpha_o - \alpha_a&lt;/math&gt;:

:&lt;math&gt;
  C_o = \frac{\alpha_a}{\alpha_o} C_a + \left(1 - \frac{\alpha_a}{\alpha_o}\right) C_b
&lt;/math&gt;

The &lt;math&gt;\odot&lt;/math&gt; operator fulfills all the requirements of a [[non-commutative]] [[monoid]], where the [[identity element]] &lt;math&gt;e&lt;/math&gt; is chosen such that &lt;math&gt;e \odot a = a \odot e = a&lt;/math&gt; (i.e. the identity element can be any tuple &lt;math&gt;\langle C,\alpha\rangle&lt;/math&gt; with &lt;math&gt;\alpha = 0&lt;/math&gt;).

==Alpha blending==

Alpha blending is the process of combining a translucent foreground color with a background color, thereby producing a new color blended between the two. The degree of the foreground color's translucency may range from completely transparent to completely opaque. If the foreground color is completely transparent, the blended color will be the background color. Conversely, if it is completely opaque, the blended color will be the foreground color. The translucency can range between these extremes, in which case the blended color is computed as a weighted average of the foreground and background colors.

Alpha blending is a [[convex combination]] of two [[color]]s allowing for [[Transparency (graphic)|transparency]] effects in [[computer graphics]]. The value of &lt;code&gt;alpha&lt;/code&gt; in the color code ranges from 0.0 to 1.0, where 0.0 represents a fully transparent color, and 1.0 represents a fully opaque color. This alpha value also corresponds to the ratio of &quot;SRC over DST&quot; in Porter and Duff equations.

The value of the resulting color is given by:

:&lt;math&gt;
\begin{cases}
\mathrm{out}_A = \mathrm{src}_A + \mathrm{dst}_A (1 - \mathrm{src}_A) \\
\mathrm{out}_\text{RGB} = \bigl( \mathrm{src}_\text{RGB} \mathrm{src}_A + \mathrm{dst}_\text{RGB} \mathrm{dst}_A \left( 1 - \mathrm{src}_A \right) \bigr) \div \mathrm{out}_A \\
\mathrm{out}_A = 0 \Rightarrow \mathrm{out}_\text{RGB} = 0
\end{cases}
&lt;/math&gt;

If the destination background is opaque, then &lt;math&gt;\text{dst}_A = 1&lt;/math&gt;, and if you enter it to the upper equation:

:&lt;math&gt;
\begin{cases}
\mathrm{out}_A = 1 \\
\mathrm{out}_\text{RGB} = \mathrm{src}_\text{RGB} \mathrm{src}_A + \mathrm{dst}_\text{RGB} (1 - \mathrm{src}_A)
\end{cases}
&lt;/math&gt;

The alpha component may be used to blend to [[red]], [[green]] and [[blue]] components equally, as in [[32-bit]] [[RGBA color space|RGBA]], or, alternatively, there may be three alpha values specified corresponding to each of the [[primary color]]s for [[spectral color]] [[filter (optics)|filtering]].

If premultiplied alpha is used, the above equations are simplified to:
:&lt;math&gt;
\begin{cases}
\mathrm{out}_A = \mathrm{src}_A + \mathrm{dst}_A (1 - \mathrm{src}_A) \\
\mathrm{out}_\text{RGB} = \mathrm{src}_\text{RGB} + \mathrm{dst}_\text{RGB} \left( 1 - \mathrm{src}_A \right)
\end{cases}
&lt;/math&gt;

==Other transparency methods==

Although used for similar purposes, [[Palette (computing)#Transparent color in palettes|transparent color]]s and [[Mask (computing)#Image masks|image mask]]s do not permit the smooth blending of the superimposed image pixels with those of the background (only whole image pixels or whole background pixels allowed).

A similar effect can be achieved with a 1-bit alpha channel, as found in the 16-bit RGBA [[Highcolor]] mode of the [[Truevision TGA]] [[image file format]] and related [[TARGA]] and AT-Vista/NU-Vista display adapters' Highcolor graphic mode. This mode devotes 5 bits for every primary RGB color ([[List of monochrome and RGB palettes#15-bit RGB|15-bit RGB]]) plus a remaining bit as the &quot;alpha channel&quot;.

==Composing alpha blending with gamma correction==

[[File:Mix lazy.png|thumb|Alpha blending, not taking into account the [[gamma correction]]]]

[[File:Mix precise.png|thumb|Alpha blending, taking into account the gamma correction. A demonstration with [[python code]] can be found [https://gist.github.com/pthom/5155d319a7957a38aeb2ac9e54cc0999 here] |alt=]]

The RGB values stored in computer images are actually not the real light intensities, but they have been transformed by a [[gamma correction]], in order to optimize the usage of bits when encoding an image.

The gamma correction can be roughly summarised as below:

* let &lt;math&gt;\text{displayed}_\text{RGB}&lt;/math&gt; be the RGB intensity that is displayed on the screen (in normalised intensities, i.e. between 0 and 1)
* let &lt;math&gt;\text{stored}_\text{RGB}&lt;/math&gt; be the RGB intensity that is stored as bits in the computer memory (in normalised intensities also)
* let &lt;math&gt;\gamma&lt;/math&gt; be the &quot;decoding&quot; gamma of 2.2  of the &lt;math&gt;\text{stored}_\text{RGB}&lt;/math&gt; image (&lt;math&gt;\gamma&lt;/math&gt; has a typical value of 2.2)
Then we have the following relation:

: &lt;math&gt;\text{displayed}_\text{RGB} = \text{stored}_\text{RGB}^\gamma&lt;/math&gt;

Thus, when dealing with computer stored RGB values, alpha blending will look much better if the gamma correction is unapplied before averaging the images and re-applied afterwards.&lt;ref&gt;{{cite web|url=https://www.youtube.com/watch?v=LKnqECcg6Gw|title=Computer Color is Broken|author=Minute Physics|first=|date=March 20, 2015|website=[[YouTube]]|url-status=live|archive-url=|archive-date=|access-date=}}&lt;/ref&gt;

For example, if one wants to superimpose an image named &lt;math&gt;overlay_\text{rgb}&lt;/math&gt; with an alpha channel &lt;math&gt;overlay_{\alpha}&lt;/math&gt; onto a background image &lt;math&gt;background_\text{rgb}&lt;/math&gt;, then the resulting image &lt;math&gt;out_\text{rgb}&lt;/math&gt; can be calculated like this:

: &lt;math&gt;
\text{out}_\text{rgb} = (\text{overlay}_\text{rgb}^\gamma \times \text{overlay}_\alpha + \text{background}_\text{rgb}^\gamma \times (1 - \text{overlay}_\alpha))^{1/\gamma }
&lt;/math&gt;

Note: &lt;math&gt;\text{out}_\text{rgb}&lt;/math&gt; is the image as it will be stored in the computer memory; and it will be displayed as &lt;math&gt;\text{out}_\text{rgb}^\gamma&lt;/math&gt; on the computer display.

==See also==
*[[Alpha to coverage]]
*[[Bit blit]]
*[[Blend modes]]
*[[Digital compositing]]
*[[Mask (computing)#Image masks|Image masks]]
*[[Magic Pink]]
*[[Portable Network Graphics]]
*[[RGBA color space]]
*[[Texture splatting]]
*[[Transparency (graphic)]]
*[[Palette (computing)#Transparent color in palettes|Transparent color in palettes]]
*[[Truevision TGA]]

==References==
{{reflist}}

==External links==
* [http://keithp.com/~keithp/porterduff/p253-porter.pdf Compositing Digital Images - Thomas Porter and Tom Duff (Original Paper)]
* [http://www.cs.princeton.edu/courses/archive/fall00/cs426/papers/smith95a.pdf Image Compositing Fundamentals]
* [http://www.svgopen.org/2005/papers/abstractsvgopen/ Understand Compositing and Color extensions in SVG 1.2 in 30 minutes!]
* [http://dvd-hq.info/alpha_matting.php Alpha Matting and Premultiplication]

{{DEFAULTSORT:Alpha Compositing}}
[[Category:Computer graphics algorithms]]</text>
      <sha1>hwnm0mjpltj7dmrbtapn5ezgi7d9aiq</sha1>
    </revision>
  </page>
