  <page>
    <title>Device driver</title>
    <ns>0</ns>
    <id>9101</id>
    <revision>
      <id>941549851</id>
      <parentid>941537535</parentid>
      <timestamp>2020-02-19T06:53:07Z</timestamp>
      <contributor>
        <username>Ravensfire</username>
        <id>4156945</id>
      </contributor>
      <comment>Reverted 3 edits by [[Special:Contributions/Muhammadsoil|Muhammadsoil]] ([[User talk:Muhammadsoil|talk]]) ([[WP:TW|TW]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve">{{About|device drivers for hardware|other software drivers|Driver (software)}}
In [[computing]], a '''device driver''' is a [[computer program]] that operates or controls a particular type of device that is attached to a computer.&lt;ref name=&quot;dev1&quot;&gt;{{cite web|title=What is a device driver?|url=http://searchenterprisedesktop.techtarget.com/definition/device-driver|website=WhatIs.com|publisher=TechTarget|accessdate=19 March 2018}}&lt;/ref&gt; A driver provides a [[software interface]] to hardware devices, enabling operating systems and other computer programs to access hardware functions without needing to know precise details about the hardware being used.

A driver communicates with the [[Peripheral|device]] through the [[computer bus]] or communications subsystem to which the hardware connects. When a calling program invokes a [[subroutine|routine]] in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. Drivers are hardware dependent and [[operating system|operating-system]]-specific. They usually provide the [[interrupt]] handling required for any necessary asynchronous time-dependent hardware interface.&lt;ref&gt;{{cite book |url=https://books.google.com/books?id=sCCfRAj3aCgC&amp;dq=device+driver+hardware+dependent&amp;hl=fil&amp;source=gbs_navlinks_s|title=Information Storage and Management: Storing, Managing, and Protecting Digital Information|year=2010|author=EMC Education Services|publisher=John Wiley &amp; Sons}}&lt;/ref&gt;

==Purpose==
The main purpose of device drivers is to provide abstraction by acting as a translator between a hardware device and the applications or [[operating system]]s that use it.&lt;ref name=&quot;dev1&quot;/&gt;  Programmers can write higher-level application code independently of whatever specific hardware the end-user is using.
For example, a high-level application for interacting with a [[serial port]] may simply have two functions for &quot;send data&quot; and &quot;receive data&quot;. At a lower level, a device driver implementing these functions would communicate to the particular serial port controller installed on a user's computer. The commands needed to control a [[16550 UART]] are much different from the commands needed to control an [[FTDI]] serial port converter, but each hardware-specific device driver [[Abstraction (computer science)|abstracts]] these details into the same (or similar) software interface.

==Development==
Writing a device driver requires an in-depth understanding of how the hardware and the software works for a given [[Computing platform|platform]] function. Because drivers require low-level access to hardware functions in order to operate, drivers typically operate in a highly [[privilege (computing)|privilege]]d environment and can cause system operational issues if something goes wrong. In contrast, most user-level software on modern [[operating system]]s can be stopped without greatly affecting the rest of the system. Even drivers executing in [[user mode]] can crash a system if the device is [[Erroneous program|erroneously programmed]]. These factors make it more difficult and dangerous to diagnose problems.&lt;ref&gt;{{cite book |url=https://books.google.com/books?id=9aFQAAAAMAAJ&amp;q=writing+a+device+driver&amp;dq=writing+a+device+driver&amp;hl=fil&amp;sa=X&amp;ei=yA2jUJyXEKmfiAes44CIAQ&amp;ved=0CC8Q6AEwAQ|title=Writing device drivers: tutorial and reference|year=1995|author=Burke, Timothy|publisher=Digital Press}}&lt;/ref&gt;

The task of writing drivers thus usually falls to [[software engineer]]s or [[computer engineer]]s who work for hardware-development companies. This is because they have better information than most outsiders about the design of their hardware. Moreover, it was traditionally considered in the hardware [[manufacturer]]'s interest to guarantee that their clients can use their hardware in an optimum way. Typically, the [[Logical Device Driver]] (LDD) is written by the operating system vendor, while the [[Physical Device Driver]] (PDD) is implemented by the device vendor. But in recent years, non-vendors have written numerous [[proprietary device driver]]s, mainly for use with [[free and open source software|free and open source]] [[operating system]]s. In such cases, it is important that the hardware manufacturer provides information on how the device communicates. Although this information can instead be learned by [[reverse engineering]], this is much more difficult with hardware than it is with software.

[[Microsoft]] has attempted to reduce system instability due to poorly written device drivers by creating a new framework for driver development, called [[Windows Driver Foundation]] (WDF).  This includes [[User-Mode Driver Framework]] (UMDF) that encourages development of certain types of drivers—primarily those that implement a [[message-based protocol]] for communicating with their devices—as user-mode drivers. If such drivers malfunction, they do not cause system instability. The [[Kernel-Mode Driver Framework]] (KMDF) model continues to allow development of kernel-mode device drivers, but attempts to provide standard implementations of functions that are known to cause problems, including cancellation of I/O operations, power management, and plug and play device support.

[[Apple Inc.|Apple]] has an open-source framework for developing drivers on [[macOS]], called [[I/O Kit]].

In [[Linux kernel|Linux]] environments, programmers can build device drivers as parts of the [[Linux kernel|kernel]], separately as loadable [[loadable kernel module|module]]s, or as user-mode drivers (for certain types of devices where kernel interfaces exist, such as for USB devices). [[Makedev]] includes a list of the devices in Linux: ttyS (terminal), lp ([[parallel port]]), hd (disk), loop, sound  (these include [[Sound card mixer|mixer]], [[Music sequencer|sequencer]], [[Digital signal processor|dsp]], and audio)...&lt;ref&gt;{{cite web
 | url = http://linux.about.com/od/commands/l/blcmdl8_MAKEDEV.htm
 | title = MAKEDEV&amp;nbsp;— Linux Command&amp;nbsp;— Unix Command
 | publisher = Linux.about.com
 | date = 2009-09-11
 | accessdate = 2009-09-17
}}&lt;/ref&gt;

The [[Microsoft Windows]] [[.sys]] files and [[Linux]] .ko modules contain loadable device drivers. The advantage of loadable device drivers is that they can be loaded only when necessary and then unloaded, thus saving kernel memory.

==Kernel mode vs. user mode==
Device drivers, particularly on {{as of | 2009 | alt = modern}} [[Microsoft Windows]] platforms, can run in [[CPU modes|kernel-mode]] ([[Ring (computer security)|Ring 0 on x86 CPUs]]) or in [[user space|user-mode]] (Ring&amp;nbsp;3 on x86 CPUs).&lt;ref&gt;{{cite web
 | url = http://technet2.microsoft.com/windowsserver/en/library/eb1936c0-e19c-4a17-a1a8-39292e4929a41033.mspx?mfr=true
 | title = User-mode vs. Kernel-mode Drivers
 | publisher = [[Microsoft]]
 | date = 2003-03-01
 | accessdate = 2008-03-04
 | archive-url = https://web.archive.org/web/20080309012600/http://technet2.microsoft.com/windowsserver/en/library/eb1936c0-e19c-4a17-a1a8-39292e4929a41033.mspx?mfr=true
 | archive-date = 2008-03-09
 | url-status = dead
 }}&lt;/ref&gt; The primary benefit of running a driver in user mode is improved stability, since a poorly written user-mode device driver cannot crash the system by overwriting kernel memory.&lt;ref&gt;{{cite web
 | url = http://blogs.msdn.com/iliast/archive/2006/10/10/Introduction-to-the-User_2D00_Mode-Driver-Framework.aspx
 | title = Introduction to the User-Mode Driver Framework (UMDF)
 | date = 2006-10-10
 | accessdate = 2008-03-04
 | publisher = [[Microsoft]]
}}&lt;/ref&gt; On the other hand, user/kernel-mode transitions usually impose a considerable performance overhead, thus making kernel-mode drivers preferred for low-latency networking.

Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX  shell or other GUI-based applications are part of the user space. These applications interact with hardware through kernel supported functions.

==Applications==
Because of the diversity of {{as of | 2009 | alt = modern}} hardware and operating systems, drivers operate in many different environments.&lt;ref&gt;{{cite book |url=https://books.google.com/books?id=tfU7RtI7OX8C&amp;dq=applications+device+driver&amp;hl=fil&amp;source=gbs_navlinks_s|title=Understanding Computers 2009: Today and Tomorrow|year=2009|author=Deborah Morley|publisher=Cengage Learning}}&lt;/ref&gt; Drivers may [[interface (computer science)|interface]] with:

* [[Computer printer|Printers]]
* [[Video card|Video adapters]]
* [[Network interface controller|Network cards]]
* [[Sound card]]s
* Local [[Computer bus|buses]] of various sorts—in particular, for [[bus mastering]] on modern systems
* Low-[[bandwidth (computing)|bandwidth]] [[input/output|I/O]] buses of various sorts (for [[pointing device]]s such as [[Computer mouse|mice]], [[Computer keyboard|keyboard]]s, [[Universal Serial Bus|USB]], etc.)
* [[Computer storage]] devices such as [[Hard disk drive|hard disk]], [[CD-ROM]], and [[floppy disk]] buses ([[Advanced Technology Attachment|ATA]], [[Serial ATA|SATA]], [[SCSI]])
* Implementing support for different [[file system]]s
* [[Image scanner]]s
* [[Digital camera]]s

Common levels of abstraction for device drivers include:
* For hardware:
** Interfacing directly
** Writing to or reading from a [[device control register]]
** Using some higher-level interface (e.g. [[Video BIOS]])
** Using another lower-level device driver (e.g. file system drivers using disk drivers)
** Simulating work with hardware, while doing something entirely different&lt;ref name=&quot;Computer Peripherals and Interfaces&quot;&gt;{{cite book|title=Computer Peripherals and Interfaces|date=January 2008|publisher=Technical Publications Pune|isbn=8184314744|pages=5–8 |url=https://books.google.co.uk/books?id=uK01xKT_mAMC&amp;pg=SA5-PA8&amp;lpg=SA5-PA8&amp;dq=Simulating+work+with+hardware,+while+doing+something+entirely+different&amp;source=bl&amp;ots=tFgCB2iFaQ&amp;sig=G4YPK6LI2KrIT7MN6IoDKt4THOk&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjhpOnBxMDMAhXHvBQKHYYMAwEQ6AEIHTAA#v=onepage&amp;q=Simulating%20work%20with%20hardware%2C%20while%20doing%20something%20entirely%20different&amp;f=false|accessdate=2016-05-03|ref=CPIbook}}&lt;/ref&gt;
* For software:
** Allowing the operating system direct access to hardware resources
** Implementing only [[primitive (computer science)|primitive]]s
** Implementing an interface for non-driver software (e.g. [[TWAIN]])
** Implementing a language, sometimes quite high-level (e.g. [[PostScript]])

So choosing and installing the correct device drivers for given hardware is often a key component of computer system configuration.&lt;ref&gt;{{cite web|url=http://www.drivers.com/update/drivers-news/what-are-device-drivers-and-why-do-we-need-them/|title=What are Device Drivers and why do we need them?|date=April 17, 2015|access-date=March 19, 2018|website=drivers.com}}&lt;/ref&gt;

==Virtual device drivers==
Virtual device drivers represent a particular variant of device drivers. They are used to emulate a hardware device, particularly in [[virtual machine|virtualization]] environments, for example when a [[DOS]] program is run on a [[Microsoft Windows]] computer or when a guest [[operating system]] is run on, for example, a [[Xen]] host. Instead of enabling the guest operating system to dialog with hardware, virtual device drivers take the opposite role and emulates a piece of hardware, so that the guest operating system and its drivers running inside a [[virtual machine]] can have the illusion of accessing real hardware. Attempts by the guest operating system to access the hardware are routed to the virtual device driver in the host operating system as e.g.,&amp;nbsp;[[function call]]s. The virtual device driver can also send simulated processor-level events like [[interrupt]]s into the virtual machine.

Virtual devices may also operate in a non-virtualized environment. For example, a virtual [[Network interface controller|network adapter]] is used with a [[virtual private network]], while a virtual [[Hard disk drive|disk]] device is used with [[iSCSI]]. A good example for virtual device drivers can be [[Daemon Tools]].

There are several variants of virtual device drivers, such as [[VxD]]s, [[VLM (NetWare)|VLM]]s, and VDDs.

==Open source drivers==
* [[Free and open-source graphics device driver|graphics device driver]]
* Printers: [[CUPS]]
* RAIDs: CCISS&lt;ref&gt;
{{cite web
| url         = http://sourceforge.net/projects/cciss/
| title       = CCISS
| year        = 2010
| work        = [[SourceForge]]
| accessdate  = 2010-08-11
| quote       = Drivers for the HP (previously Compaq) Smart Array controllers which provide hardware RAID capability.
}}
&lt;/ref&gt; (Compaq Command Interface for SCSI-3 Support&lt;ref&gt;{{cite web
 |url             = http://www.redbooks.ibm.com/redbooks/pdfs/sg246852.pd
 |title           = Abbreviations and acronyms
 |first           = Steve
 |last            = Russell
 |date            = 2003-10-21
 |work            = Server Consolidation with the IBM eserver xSeries 440 and VMware ESX Serve
 |publisher       = IBM International Technical Support Organization
 |page            = 207
 |isbn            = 0-7384-2684-9
 |accessdate      = 2011-08-14
 |display-authors = etal
}}{{Dead link|date=July 2019 |bot=InternetArchiveBot |fix-attempted=yes }}&lt;/ref&gt;)
* Scanners: [[Scanner Access Now Easy|SANE]]
* Video: [[Vidix]], [[Direct Rendering Infrastructure]]

[[Solaris (operating system)|Solaris]] descriptions of commonly used device drivers:
* fas: Fast/wide SCSI controller
* hme: Fast (10/100 Mbit/s) Ethernet
* isp: Differential SCSI controllers and the SunSwift card
* glm: (Gigabaud Link Module&lt;ref&gt;{{cite web
 | title = US Patent 5969841 - Gigabaud link module with received power detect signal
 | url = http://www.patentstorm.us/patents/5969841.html
 | publisher = PatentStorm LLC
 | accessdate = 2009-09-08
 | quote = An improved Gigabaud Link Module (GLM) is provided for performing bi-directional data transfers between a host device and a serial transfer medium.
 | archive-url = https://web.archive.org/web/20110612215844/http://www.patentstorm.us/patents/5969841.html
 | archive-date = 2011-06-12
 | url-status = dead
 }}&lt;/ref&gt;) UltraSCSI controllers
* scsi: Small Computer Serial Interface (SCSI) devices
* sf: soc+ or social Fiber Channel Arbitrated Loop (FCAL)
* soc: SPARC Storage Array (SSA) controllers and the control device
* social: Serial optical controllers for FCAL (soc+)

==APIs==
* [[Windows Display Driver Model]] (WDDM) – the graphic display driver architecture for [[Windows Vista]], [[Windows 7]], [[Windows 8]], and [[Windows 10]].
* Unified Audio Model (UAM)&lt;ref&gt;{{Cite web|url=https://msdn.microsoft.com/en-us/library/ms894071.aspx|title=Unified Audio Model (Windows CE 5.0)|website=msdn.microsoft.com|access-date=2016-09-19}}&lt;/ref&gt;
* [[Windows Driver Foundation]] (WDF)
* [[Windows Driver Model]] (WDM)
* [[Network Driver Interface Specification]] (NDIS) – a standard [[network card]] driver API
* [[Advanced Linux Sound Architecture]] (ALSA) – {{as of | 2009 | lc = on}} the standard Linux sound-driver interface
* [[Scanner Access Now Easy]] (SANE) – a public-domain interface to raster-image scanner-hardware
* [[I/O Kit]] – an open-source framework from [[Apple Computer|Apple]] for developing [[macOS]] device drivers
* [[Installable File System]] (IFS) – a [[filesystem API]] for IBM OS/2 and Microsoft Windows NT
* [[Open Data-Link Interface]] (ODI) – a network card API similar to NDIS
* [[Uniform Driver Interface]] (UDI) – a cross-platform driver interface project
* Dynax Driver Framework (dxd) – C++ open source cross-platform driver framework for KMDF and IOKit&lt;ref&gt;{{Cite web|url=https://dxd.dynax.at/|title=dxd - dynax driver framework: Main Page|website=dxd.dynax.at|access-date=2016-09-19}}&lt;/ref&gt;

==Identifiers==
A device on the [[Conventional PCI|PCI bus]] or USB is identified by two IDs which consist of 4 [[hexadecimal]] numbers each. The vendor ID identifies the vendor of the device. The device ID identifies a specific device from that manufacturer/vendor.

A PCI device has often an ID pair for the main chip of the device, and also a subsystem ID pair which identifies the vendor, which may be different from the chip manufacturer.

==See also==
{{Div col|colwidth=22em}}
* [[Driver (software)]]
* [[Class driver]]
* [[Controller (computing)]]
* [[Device driver synthesis and verification]]
* [[Driver wrapper]]
* [[Free software]]
* [[Firmware]]
* [[Interrupt]]
* [[Loadable kernel module]]
* [[Makedev]]
* [[Open-source hardware]]
* [[Printer driver]]
* [[Replicant (operating system)]]
* [[udev]]
{{Div col end}}

==References==
{{Reflist|30em}}

==External links==
&lt;!-- Please discuss links before adding them here. Due to a tendency to attract spam, undiscussed additional links will be periodically removed. --&gt;
* [https://developer.microsoft.com/en-us/windows/hardware Windows Hardware Dev Center]
* [https://web.archive.org/web/20190819193521/https://www.linux-drivers.org/ Linux Hardware Compatibility Lists and Linux Drivers]
* [http://pages.cs.wisc.edu/~kadav/study/study.pdf Understanding Modern Device Drivers(Linux)]
* [https://help.ubuntu.com/community/BinaryDriverHowto/ BinaryDriverHowto, Ubuntu.]
* [https://github.com/torvalds/linux/tree/master/drivers Linux Drivers Source]

{{Operating System}}

{{Authority control}}

{{DEFAULTSORT:Device Driver}}
[[Category:Device drivers| ]]
[[Category:Linux drivers]]
[[Category:Computing terminology]]
[[Category:Windows NT kernel]]</text>
      <sha1>t8mo89s4q692nmye6514kr8wr5l4qql</sha1>
    </revision>
  </page>
