  <page>
    <title>Garbage collection (computer science)</title>
    <ns>0</ns>
    <id>6734</id>
    <revision>
      <id>942661589</id>
      <parentid>942369213</parentid>
      <timestamp>2020-02-26T01:48:20Z</timestamp>
      <contributor>
        <username>Matthiaspaul</username>
        <id>13467261</id>
      </contributor>
      <comment>/* Further reading */ improved refs</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve">{{short description|Form of automatic memory management}}
{{Use dmy dates|date=April 2019|cs1-dates=y}}
{{About|garbage collection in memory management|garbage collection in a solid-state drive|garbage collection (SSD)}}
{{Other uses|Garbage collection (disambiguation)}}

In [[computer science]], '''garbage collection''' ('''GC''') is a form of automatic [[memory management]]. The ''garbage collector'', or just ''collector'', attempts to reclaim ''[[garbage (computer science)|garbage]]'', or memory occupied by [[object (computer science)|objects]] that are no longer in use by the [[application software|program]]. Garbage collection was invented by [[John McCarthy (computer scientist)|John McCarthy]] around 1959 to simplify manual memory management in [[Lisp (programming language)|Lisp]].&lt;ref&gt;{{cite journal |title=Recursive functions of symbolic expressions and their computation by machine, Part I |journal=Communications of the ACM|volume=3|issue=4|pages=184–195|doi=10.1145/367177.367199|url=http://www-formal.stanford.edu/jmc/recursive.html|accessdate=29 May 2009|year=1960|last1=McCarthy|first1=John}}&lt;/ref&gt;

Garbage collection is essentially the opposite of [[manual memory management]], which requires the programmer to specify which objects to deallocate and return to the memory system. However, many systems use a combination of approaches, including other techniques such as [[Stack-based memory allocation|stack allocation]] and [[region inference]]. Like other memory management techniques, garbage collection may take a significant proportion of total processing time in a program and, as a result, can have significant influence on performance. With good implementations and with enough memory, depending on application, garbage collection can be faster than manual memory management, while the opposite can also be true and has often been the case in the past with sub-optimal GC algorithms.

Resources other than memory, such as [[network socket]]s, database [[handle (computing)|handle]]s, [[window (computing)|user interaction window]]s, [[file (computing)|file]] and device descriptors, are not typically handled by garbage collection. [[Method (computer programming)|Methods]] used to manage such resources, particularly [[destructor (computer science)|destructors]], may suffice to manage memory as well, leaving no need for GC. Some GC systems allow such other resources to be associated with a region of memory that, when collected, causes the work of reclaiming these resources.

== Principles ==
{{Refimprove section|date=July 2014}}

The basic principles of garbage collection are to find data objects in a program that cannot be accessed in the future, and to reclaim the resources used by those objects.

Many [[programming language]]s require garbage collection, either as part of the [[language specification]] (for example, [[Java (programming language)|Java]], [[C Sharp (programming language)|C#]], [[D (programming language)|D]],&lt;ref&gt;{{cite web |url=http://dlang.org/overview.html |title=Overview&amp;nbsp;— D Programming Language |website=dlang.org |publisher=Digital Mars |accessdate=2014-07-29 }}&lt;/ref&gt; [[Go (programming language)|Go]] and most [[scripting language]]s) or effectively for practical implementation (for example, formal languages like [[lambda calculus]]); these are said to be ''garbage collected languages''. Other languages were designed for use with manual memory management, but have garbage-collected implementations available (for example, [[C (programming language)|C]] and [[C++]]). Some languages, like [[Ada (programming language)|Ada]], [[Modula-3]], and [[C++/CLI]], allow both garbage collection and [[manual memory management]] to co-exist in the same application by using separate [[Heap (data structure)|heaps]] for collected and manually managed objects; others, like [[D (programming language)|D]], are garbage-collected but allow the user to manually delete objects and also entirely disable garbage collection when speed is required.

While integrating garbage collection into the language's [[compiler]] and [[runtime system]] enables a much wider choice of methods,{{Citation needed|date=June 2007}} ''post-hoc'' GC systems exist, such as [[Automatic Reference Counting]] (ARC), including some that do not require recompilation. (''Post-hoc'' GC is sometimes distinguished as ''litter collection''.) The garbage collector will almost always be closely integrated with the [[dynamic memory allocation|memory allocator]].

=== Advantages ===
Garbage collection frees the programmer from manually dealing with memory deallocation. As a result, certain categories of [[bug (software)|bug]]s are eliminated or substantially reduced:

* ''[[Dangling pointer]] bugs'', which occur when a piece of memory is freed while there are still [[pointer (computer programming)|pointer]]s to it, and one of those pointers is [[Dereference_operator|dereferenced]]. By then the memory may have been reassigned to another use, with unpredictable results.
* ''Double free bugs'', which occur when the program tries to free a region of memory that has already been freed, and perhaps already been allocated again.
* Certain kinds of ''[[memory leak]]s'', in which a program fails to free memory occupied by objects that have become [[unreachable]], which can lead to memory exhaustion. (Garbage collection typically{{who|date=June 2018}} does not deal with the unbounded accumulation of data that is reachable, but that will actually not be used by the program.)
* Efficient implementations of [[persistent data structure]]s

Some of the bugs addressed by garbage collection have security implications.

=== Disadvantages ===
Typically, garbage collection has certain disadvantages, including consuming additional resources, performance impacts, possible stalls in program execution, and incompatibility with manual resource management.

Garbage collection consumes computing resources in deciding which memory to free, even though the programmer may have already known this information. The penalty for the convenience of not annotating object lifetime manually in the source code is [[overhead (computing)|overhead]], which can lead to decreased or uneven performance.&lt;ref name=&quot;zorn1993&quot;&gt;{{cite journal|citeseerx=10.1.1.14.1816 |first=Benjamin |last=Zorn |title=The Measured Cost of Conservative Garbage Collection |journal=Software Practice and Experience |volume=23 |issue=7 |pages=733–756 |publisher=Department of Computer Science, [[University of Colorado Boulder]] |date=1993-01-22|doi=10.1002/spe.4380230704 }}&lt;/ref&gt; A peer-reviewed paper from 2005 came to the conclusion that GC needs five times the memory to compensate for this overhead and to perform as fast as explicit memory management.&lt;ref&gt;{{cite book|chapter-url=https://people.cs.umass.edu/~emery/pubs/gcvsmalloc.pdf |chapter=Quantifying the Performance of Garbage Collection vs. Explicit Memory Management |author1=Matthew Hertz|title=Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications - OOPSLA '05 |pages=313 |author2= Emery D. Berger |date=2005 |accessdate=2015-03-15 |doi=10.1145/1094811.1094836 |isbn=1595930310 }}&lt;/ref&gt; Interaction with memory hierarchy effects can make this overhead intolerable in circumstances that are hard to predict or to detect in routine testing. The impact on performance was also given by Apple as a reason for not adopting garbage collection in [[iOS]] despite being the most desired feature.&lt;ref name=&quot;wwdc2011&quot;&gt;{{cite web |url=https://developer.apple.com/devcenter/download.action?path=/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/300developer_tools_kickoff.pdf |work=[[WWDC]] 2011|title=Developer Tools Kickoff&amp;nbsp;— session 300 |publisher=Apple, inc. |date=2011-06-24 |accessdate=2015-03-27}}&lt;/ref&gt;

The moment when the garbage is actually collected can be unpredictable, resulting in stalls (pauses to shift/free memory) scattered throughout a session. Unpredictable stalls can be unacceptable in [[real-time computing|real-time environments]], in [[transaction processing]], or in interactive programs. Incremental, concurrent, and real-time garbage collectors address these problems, with varying trade-offs.

The modern GC implementations try to minimize blocking &quot;[[stop-the-world]]&quot; stalls by doing as much work as possible on the background (i.e. on a separate thread), for example marking unreachable garbage instances while the application process continues to run. In spite of these advancements, for example in the [[Common Language Runtime|.NET CLR paradigm]] it is still very difficult to maintain large heaps (millions of objects) with resident objects that get promoted to older generations without incurring noticeable delays (sometimes a few seconds).

The need for explicit manual resource management (release/close) for non-GCed resources in an object oriented language becomes transitive to composition. That is: in a non-deterministic GC system, if a resource or a resource-like object requires manual resource management (release/close), and this object is used as &quot;part of&quot; another object, then the composed object will also become a resource-like object that itself requires manual resource management (release/close).

== Strategies ==

=== Tracing ===
{{Main|Tracing garbage collection}}

[[Tracing garbage collection]] is the most common type of garbage collection, so much so that &quot;garbage collection&quot; often refers to tracing garbage collection, rather than other methods such as [[reference counting]]. The overall strategy consists of determining which objects should be garbage collected by tracing which objects are ''reachable'' by a chain of references from certain root objects, and considering the rest as garbage and collecting them. However, there are a large number of algorithms used in implementation, with widely varying complexity and performance characteristics.

=== Reference counting ===
{{Main|Reference counting}}

Reference counting garbage collection is where each object has a count of the number of references to it. Garbage is identified by having a reference count of zero. An object's reference count is incremented when a reference to it is created, and decremented when a reference is destroyed. When the count reaches zero, the object's memory is reclaimed.&lt;ref&gt;[https://blogs.msdn.microsoft.com/abhinaba/2009/01/27/back-to-basics-reference-counting-garbage-collection/ Reference Counting Garbage Collection]&lt;/ref&gt;

As with manual memory management, and unlike tracing garbage collection, reference counting guarantees that objects are destroyed as soon as their last reference is destroyed, and usually only accesses memory which is either in CPU caches, in objects to be freed, or directly pointed by those, and thus tends to not have significant negative side effects on CPU cache and virtual memory operation.

There are a number of disadvantages to reference counting; this can generally be solved or mitigated by more sophisticated algorithms:

; Cycles: If two or more objects refer to each other, they can create a cycle whereby neither will be collected as their mutual references never let their reference counts become zero. Some garbage collection systems using reference counting (like the one in [[CPython]]) use specific cycle-detecting algorithms to deal with this issue.&lt;ref&gt;{{cite web|url=https://docs.python.org/release/2.5.2/ext/refcounts.html|accessdate=22 May 2014|date=21 February 2008|title=Reference Counts|work=Extending and Embedding the Python Interpreter }}&lt;/ref&gt; Another strategy is to use [[weak reference]]s for the &quot;backpointers&quot; which create cycles. Under reference counting, a weak reference is similar to a weak reference under a tracing garbage collector. It is a special reference object whose existence does not increment the reference count of the referent object. Furthermore, a weak reference is safe in that when the referent object becomes garbage, any weak reference to it ''lapses'', rather than being permitted to remain dangling, meaning that it turns into a predictable value, such as a null reference.
; Space overhead (reference count): Reference counting requires space to be allocated for each object to store its reference count. The count may be stored adjacent to the object's memory or in a side table somewhere else, but in either case, every single reference-counted object requires additional storage for its reference count. Memory space with the size of an unsigned pointer is commonly used for this task, meaning that 32 or 64 bits of reference count storage must be allocated for each object. On some systems, it may be possible to mitigate this overhead by using a [[tagged pointer]] to store the reference count in unused areas of the object's memory. Often, an architecture does not actually allow programs to access the full range of memory addresses that could be stored in its native pointer size; certain number of high bits in the address is either ignored or required to be zero. If an object reliably has a pointer at a certain location, the reference count can be stored in the unused bits of the pointer. For example, each object in [[Objective-C]] has a pointer to its [[class (computer programming)|class]] at the beginning of its memory; on the [[ARM64]] architecture using [[iOS 7]], 19 unused bits of this class pointer are used to store the object's reference count.&lt;ref&gt;{{cite web|author=Mike Ash |url=https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html |title=Friday Q&amp;A 2013-09-27: ARM64 and You |publisher=mikeash.com |accessdate=2014-04-27}}&lt;/ref&gt;&lt;ref&gt;{{cite web|url=http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html |title=Hamster Emporium: [objc explain&amp;#93;: Non-pointer isa |publisher=Sealiesoftware.com |date=2013-09-24 |accessdate=2014-04-27}}&lt;/ref&gt;
; Speed overhead (increment/decrement):In naive implementations, each assignment of a reference and each reference falling out of scope often require modifications of one or more reference counters. However, in the common case, when a reference is copied from an outer scope variable into an inner scope variable, such that the lifetime of the inner variable is bounded by the lifetime of the outer one, the reference incrementing can be eliminated. The outer variable &quot;owns&quot; the reference. In the programming language C++, this technique is readily implemented and demonstrated with the use of &lt;code&gt;const&lt;/code&gt; references. Reference counting in C++ is usually implemented using &quot;[[smart pointer]]s&quot;&lt;ref&gt;[http://www.codeproject.com/Articles/10141/RAII-Dynamic-Objects-and-Factories-in-C#1 RAII, Dynamic Objects, and Factories in C++, Roland Pibinger, 3 May 2005]&lt;/ref&gt; whose constructors, destructors and assignment operators manage the references. A smart pointer can be passed by reference to a function, which avoids the need to copy-construct a new smart pointer (which would increase the reference count on entry into the function and decrease it on exit). Instead the function receives a reference to the smart pointer which is produced inexpensively. The Deutsch-Bobrow method of reference counting capitalizes on the fact that most reference count updates are in fact generated by references stored in local variables. It ignores these references, only counting references in the heap, but before an object with reference count zero can be deleted, the system must verify with a scan of the stack and registers that no other reference to it still exists. A further substantial decrease in the overhead on counter updates can be obtained by update coalescing introduced by Levanoni and [[Erez Petrank|Petrank]].&lt;ref name=&quot;Levanoni1&quot;&gt;{{cite conference|author=Yossi Levanoni, [[Erez Petrank]]|year=2001|title=An on-the-fly reference-counting garbage collector for java|url=https://www.cs.technion.ac.il/~erez/Papers/refcount.ps|conference=[[OOPSLA]] 2001|booktitle=Proceedings of the 16th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications|pages=367–380|doi=10.1145/504282.504309}}&lt;/ref&gt;&lt;ref name=&quot;Levanoni2&quot;&gt;{{cite journal|author=Yossi Levanoni, [[Erez Petrank]]|year=2006|title=An on-the-fly reference-counting garbage collector for java|url=https://www.cs.technion.ac.il/~erez/Papers/refcount.ps|journal=ACM Trans. Program. Lang. Syst.|booktitle=ACM Trans. Program. Lang. Syst.|pages=31–69|doi=10.1145/1111596.1111597|volume=28|citeseerx=10.1.1.15.9106}}&lt;/ref&gt; Consider a pointer that in a given interval of the execution is updated several times. It first points to an object &lt;code&gt;O1&lt;/code&gt;, then to an object &lt;code&gt;O2&lt;/code&gt;, and so forth until at the end of the interval it points to some object &lt;code&gt;On&lt;/code&gt;. A reference counting algorithm would typically execute &lt;code&gt;rc(O1)--&lt;/code&gt;, &lt;code&gt;rc(O2)++&lt;/code&gt;, &lt;code&gt;rc(O2)--&lt;/code&gt;, &lt;code&gt;rc(O3)++&lt;/code&gt;, &lt;code&gt;rc(O3)--&lt;/code&gt;, ..., &lt;code&gt;rc(On)++&lt;/code&gt;. But most of these updates are redundant. In order to have the reference count properly evaluated at the end of the interval it is enough to perform &lt;code&gt;rc(O1)--&lt;/code&gt; and &lt;code&gt;rc(On)++&lt;/code&gt;. Levanoni and Petrank measured an elimination of more than 99% of the counter updates in typical Java benchmarks.

; Requires atomicity:When used in a [[thread (computing)|multithreaded]] environment, these modifications (increment and decrement) may need to be [[atomic operation]]s such as [[compare-and-swap]], at least for any objects which are shared, or potentially shared among multiple threads. Atomic operations are expensive on a multiprocessor, and even more expensive if they have to be emulated with software algorithms. It is possible to avoid this issue by adding per-thread or per-CPU reference counts and only accessing the global reference count when the local reference counts become or are no longer zero (or, alternatively, using a binary tree of reference counts, or even giving up deterministic destruction in exchange for not having a global reference count at all), but this adds significant memory overhead and thus tends to be only useful in special cases (it is used, for example, in the reference counting of Linux kernel modules).   &lt;br /&gt; Update coalescing by Levanoni and Petrank &lt;ref name=&quot;Levanoni1&quot; /&gt;&lt;ref name=&quot;Levanoni2&quot; /&gt; can be used to eliminate all atomic operations from the write-barrier. Counters are never updated by the program threads in the course of program execution execution. They are only modified by the collector which executes as a single additional thread with no synchronization. This method can be used as a stop-the-world mechanism for parallel programs, and also with a concurrent reference counting collector.

; Not real-time: Naive implementations of reference counting do not in general provide real-time behavior, because any pointer assignment can potentially cause a number of objects bounded only by total allocated memory size to be recursively freed while the thread is unable to perform other work. It is possible to avoid this issue by delegating the freeing of objects whose reference count dropped to zero to other threads, at the cost of extra overhead.

=== Escape analysis ===
{{Main|Escape analysis}}

[[Escape analysis]] is a compile-time technique that can convert [[heap allocation]]s to [[stack allocation]]s, thereby reducing the amount of garbage collection to be done. This analysis determines whether an object allocated inside a function is accessible outside of it. If a function-local allocation is found to be accessible to another function or thread, the allocation is said to “escape” and cannot be done on the stack. Otherwise, the object may be allocated directly on the stack and released when the function returns, bypassing the heap and associated memory management costs.&lt;ref&gt;{{Cite journal |last=Salagnac |display-authors=etal |first=G |date=24 May 2005 |title=Fast Escape Analysis for Region-based Memory Management |journal=Electronic Notes in Theoretical Computer Science |volume=131 |pages=99–110 |doi=10.1016/j.entcs.2005.01.026 |doi-access=free}}&lt;/ref&gt;

=== Timestamp &amp; Heartbeat ===
This is not a classical garbage collection algorithm used to collect unused memory instead this is a technique to primarily handle garbage collection of heterogenous resources (file handlers, network pointers etc). The method is used to garbage collect unused resources from the system and avoid running out of system resources (including memory). the common method is to check if the system resource is still alive and being used. The simplest of these are network algorithms sending so called heartbeat signals to a monitor. In this case the resources in on the monitor server are freed when a client fails to send a heartbeat to the monitor server. Timestamp methods can work as garbage collectors for collection of unused memory but have serious drawbacks for this task and are used when other methods are not practical (i.e network tasks). 

== Availability ==
Generally speaking, [[high-level programming language|higher-level programming languages]] are more likely to have garbage collection as a standard feature. In some languages that do not have built in garbage collection, it can be added through a library, as with the [[Boehm garbage collector]] for C and C++.

Most [[functional programming language]]s, such as [[ML (programming language)|ML]], [[Haskell (programming language)|Haskell]], and [[APL (programming language)|APL]], have garbage collection built in. [[Lisp (programming language)|Lisp]] is especially notable as both the first [[functional programming language]] and the first language to introduce garbage collection.&lt;ref&gt;{{Cite book|url=http://www.informit.com/articles/article.aspx?p=1671639|title=Influential Programming Languages, Part 4: Lisp|last=Chisnall|first=David|date=2011-01-12}}&lt;/ref&gt;

Other dynamic languages, such as [[Ruby (programming language)|Ruby]] and [[Julia (programming language)|Julia]] (but not [[Perl]]&amp;nbsp;5 or [[PHP]] before version 5.3,&lt;ref&gt;{{cite web |url=http://php.net/manual/en/features.gc.performance-considerations.php |title=PHP: Performance Considerations |website=php.net |accessdate=14 January 2015}}&lt;/ref&gt; which both use reference counting), [[JavaScript]] and [[ECMAScript]] also tend to use GC. [[Object-oriented programming]] languages such as [[Smalltalk]] and [[Java (programming language)|Java]] usually provide integrated garbage collection. Notable exceptions are [[C++]] and [[Embarcadero Delphi|Delphi]] which have [[destructor (computer science)|destructors]].

=== BASIC ===
Historically, languages intended for beginners, such as [[BASIC]] and [[Logo (programming language)|Logo]], have often used garbage collection for heap-allocated variable-length data types, such as strings and lists, so as not to burden programmers with manual memory management. On early microcomputers, with their limited memory and slow processors, BASIC garbage collection could often cause apparently random, inexplicable pauses in the midst of program operation.

Some BASIC interpreters, such as [[Applesoft BASIC]] on the Apple II family, repeatedly scanned the string descriptors for the string having the highest address in order to compact it toward high memory, resulting in [[Big O notation|O(n&lt;sup&gt;2&lt;/sup&gt;)]] performance, which could introduce minutes-long pauses in the execution of string-intensive programs. A replacement garbage collector for Applesoft BASIC published in [[Call-A.P.P.L.E.]] (January 1981, pages 40–45, [[Randy Wigginton]]) identified a group of strings in every pass over the heap, which cut collection time dramatically. BASIC.System, released with [[ProDOS]] in 1983, provided a windowing garbage collector for BASIC that reduced most collections to a fraction of a second.

=== Objective-C ===
While the [[Objective-C]] traditionally had no garbage collection, with the release of [[OS&amp;nbsp;X 10.5]] in 2007 [[Apple Inc.|Apple]] introduced garbage collection for [[Objective-C]]&amp;nbsp;2.0, using an in-house developed runtime collector.&lt;ref&gt;[https://web.archive.org/web/20100724195423/http://developer.apple.com/leopard/overview/objectivec2.html Objective-C 2.0 Overview]&lt;/ref&gt;
However, with the 2012 release of [[OS&amp;nbsp;X 10.8]], garbage collection was deprecated in favor of [[LLVM]]'s [[Automatic Reference Counting|automatic reference counter]] (ARC) that was introduced with [[OS&amp;nbsp;X 10.7]].&lt;ref&gt;[https://arstechnica.com/apple/2011/07/mac-os-x-10-7/11/ Mac OS X 10.7 Lion: the Ars Technica review] John Siracusa (20 Juli 2011)&lt;/ref&gt; Furthermore, since May 2015 Apple even forbids the usage of garbage collection for new OS&amp;nbsp;X applications in the [[App Store (iOS)|App Store]].&lt;ref name=&quot;Appleinsider2015&quot;/&gt;&lt;ref name=&quot;heiseMacOSARC&quot;&gt;{{cite web|url=http://www.heise.de/developer/meldung/App-Store-Apple-entfernt-Programme-mit-Garbage-Collection-2557111.html |title=App Store: Apple entfernt Programme mit Garbage Collection |date=2015-02-21 |accessdate=2015-03-30 |publisher=[[Heise.de]] |first=Waldemar |last=Cichon}}&lt;/ref&gt; For [[iOS]], garbage collection has never been introduced due to problems in application responsivity and performance;&lt;ref name=&quot;wwdc2011&quot;/&gt;&lt;ref&gt;{{cite web|url=http://au.ibtimes.com/ios-8-vs-android-50-lollipop-apple-kills-google-memory-efficiency-1389704/|title=iOS 8 vs Android 5.0 Lollipop: Apple Kills Google with Memory Efficiency |first=Precious |last=Silva |website=[[International Business Times]] |accessdate=2015-04-07|date=2014-11-18}}&lt;/ref&gt; instead, iOS uses ARC.&lt;ref name=&quot;iosARC&quot;&gt;{{cite book|url=https://books.google.com/?id=-vg0Xe80W4oC&amp;lpg=PT83&amp;dq=arc%20runtime%20garbage%20collection&amp;pg=PT83#v=onepage&amp;q=arc%20runtime%20garbage%20collection&amp;f=false |title=iOS 6 Programming Pushing the Limit |author=Rob Napier, Mugunth Kumar |accessdate=2015-03-30 |date=2012-11-20 |publisher=[[John Wiley &amp; Sons]]|isbn=9781118449974 }}&lt;/ref&gt;&lt;ref name=&quot;DrDobbsARC&quot;&gt;{{cite web|url=http://www.drdobbs.com/mobile/automatic-reference-counting-on-ios/240000820 |title=Automatic Reference Counting on iOS |first=José R.C. |last=Cruz |date=2012-05-22 |publisher=[[Dr. Dobbs]] |accessdate=2015-03-30}}&lt;/ref&gt;

=== Limited environments ===

Garbage collection is rarely used on [[embedded computing|embedded]] or real-time systems because of the usual need for very tight control over the use of limited resources. However, garbage collectors compatible with many limited environments have been developed.&lt;ref&gt;{{cite book|doi=10.1145/1140389.1140392|chapter=A real-time garbage collection framework for embedded systems|title=Proceedings of the 2005 Workshop on Software and Compilers for Embedded Systems - SCOPES '05|pages=20–26|year=2005|last1=Fu|first1=Wei|last2=Hauser|first2=Carl|isbn=1595932070}}&lt;/ref&gt; The Microsoft [[.NET Micro Framework]], [https://nanoframework.net/ .NET nanoFramework] and [[Java Platform, Micro Edition]] are embedded software platforms that, like their larger cousins, include garbage collection.

=== Garbage Collectors for JDK ===
Among the most popular Garbage Collectors for JDK could be named:

*[[Garbage-first collector|G1]]

* Parallel

*[[Concurrent mark sweep collector]] (CMS)

* Serial

* Shenandoah
*ZGC

Comparing Garbage Collectors is a complex task, and different applications can have very different needs. Among the factors of importance are performance overhead (how is the application slowed by the garbage collector), stop-the-world pauses times, frequency and distribution (when the garbage collector freezes the application, how long does it take to complete the process, and how often does this phenomenon happens), scalability, memory allocation performance, ...&lt;ref&gt;{{Cite web|url=https://blog.plan99.net/modern-garbage-collection-part-2-1c88847abcfd|title=Modern garbage collection: Part 2|last=Hearn|first=Mike|date=2019-06-09|website=Medium|language=en|access-date=2019-09-09}}&lt;/ref&gt;

=== Compile-time use ===
[[Compile-time garbage collection]] is a form of [[static program analysis|static analysis]] allowing memory to be reused and reclaimed based on invariants known during compilation. 

This form of garbage collection has been studied in the [[Mercury (programming language)|Mercury programming language]],&lt;ref&gt;{{cite thesis|url=https://mercurylang.org/documentation/papers/CW2004_03_mazur.pdf|title=Compile-time garbage collection for the declarative language Mercury|first=Nancy |last=Mazur |date=May 2004 |publisher=[[Katholieke Universiteit Leuven]]}}&lt;/ref&gt; and it saw greater usage with the introduction of [[LLVM]]'s [[Automatic Reference Counting|automatic reference counter]] (ARC) into Apple's ecosystem (iOS and OS&amp;nbsp;X) in 2011.&lt;ref name=&quot;iosARC&quot;/&gt;&lt;ref name=&quot;DrDobbsARC&quot;/&gt;&lt;ref name=&quot;Appleinsider2015&quot;&gt;[http://appleinsider.com/articles/15/02/20/apple-says-mac-app-makers-must-transition-to-arc-memory-management-by-may Apple says Mac app makers must transition to ARC memory management by May] by AppleInsider (February 20, 2015)&lt;/ref&gt;

=== Real-time systems ===
Incremental, concurrent, and real-time garbage collectors have been developed, such as [[Henry Baker (computer scientist) | Baker's]] algorithm or [[Henry Lieberman|Lieberman]]'s algorithm.&lt;ref&gt;{{cite book|doi=10.1145/286860.286878|chapter-url=http://doc.cat-v.org/inferno/concurrent_gc/concurrent_gc.pdf|chapter=Very concurrent mark-&amp;-sweep garbage collection without fine-grain synchronization|title=Proceedings of the First International Symposium on Memory Management - ISMM '98|pages=166–175|year=1998|last1=Huelsbergen|first1=Lorenz|last2=Winterbottom|first2=Phil|isbn=1581131143}}&lt;/ref&gt;&lt;ref&gt;[http://www.iecc.com/gclist/GC-faq.html &quot;GC FAQ&quot;].&lt;/ref&gt;&lt;ref name=&quot;lieberman&quot; &gt;{{cite journal|doi=10.1145/358141.358147|url=https://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html|title=A real-time garbage collector based on the lifetimes of objects|journal=Communications of the ACM|volume=26|issue=6|pages=419–429|year=1983|last1=Lieberman|first1=Henry|last2=Hewitt|first2=Carl|hdl=1721.1/6335}}&lt;/ref&gt;

In Baker's algorithm, the allocation is done in either half of a single region of memory. When it becomes half full, a garbage collection is performed which moves the live objects into the other half and the remaining objects are implicitly deallocated. The running program (the 'mutator') has to check that any object it references is in the correct half, and if not move it across, while a background task is finding all of the objects.&lt;ref&gt;{{cite journal|doi=10.1145/359460.359470|title=List processing in real time on a serial computer|journal=Communications of the ACM|volume=21|issue=4|pages=280–294|year=1978|last1=Baker|first1=Henry G.|hdl=1721.1/41976}} see also [http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html description]&lt;/ref&gt;

[[Tracing garbage collection#Generational GC (ephemeral GC)|Generational garbage collection]] schemes are based on the empirical observation that most objects die young. In generational garbage collection two or more allocation regions (generations) are kept, which are kept separate based on object's age. New objects are created in the &quot;young&quot; generation that is regularly collected, and when a generation is full, the objects that are still referenced from older regions are copied into the next oldest generation. Occasionally a full scan is performed.

Some [[high-level language computer architecture]]s include hardware support for real-time garbage collection.

Most implementations of real-time garbage collectors [[tracing garbage collection#Real-time garbage collection|use tracing]].{{Citation needed|date=September 2019}} Such real-time garbage collectors meet [[hard real-time]] constraints when used with a real-time operating system.&lt;ref&gt;McCloskey, Bacon, Cheng, Grove.[http://researcher.watson.ibm.com/researcher/files/us-groved/rc24504.pdf &quot;Staccato: A Parallel and Concurrent Real-time Compacting Garbage Collector for Multiprocessors&quot;]. 2008.&lt;/ref&gt;

== See also ==
{{Portal|Computer programming}}

* [[Destructor (computer programming)]]
* [[International Symposium on Memory Management]]
* [[Memory management]]
* [[Dead-code elimination]]
* [[Smart pointer]]
* [[Virtual memory compression]]

== References ==
{{refs|30em}}

== Further reading ==
* {{cite book |title=The Garbage Collection Handbook: The Art of Automatic Memory Management |date=2011-08-16 |author-first1=Richard |author-last1=Jones |author-first2=Antony |author-last2=Hosking |author-first3=J. Eliot B. |author-last3=Moss |publisher=[[Chapman and Hall]] / [[CRC Press]] / [[Taylor &amp; Francis Ltd]] |series=CRC Applied Algorithms and Data Structures Series |edition= |isbn=978-1-4200-8279-1}} (511 pages)
* {{cite book |title=Garbage Collection: Algorithms for Automatic Dynamic Memory Management |date=1996-07-12 |edition=1 |author-first1=Richard |author-last1=Jones |author-first2=Rafael |author-last2=Lins |publisher=[[Wiley (publisher)|Wiley]] |isbn=978-0-47194148-4}} (404 pages)
* {{cite journal |author-first1=Paul R. |author-last1=Wilson |title=Uniprocessor Garbage Collection Techniques |citeseerx=10.1.1.47.2438 |date=1992 |journal=[[Proceedings of the International Workshop on Memory Management]] (IWMM 92) |volume=637 |pages=1–42 |publisher=[[Springer-Verlag]] |doi=10.1007/bfb0017182|series=Lecture Notes in Computer Science |isbn=3-540-55940-X}}
* {{cite journal |author-first1=Paul R. |author-last1=Wilson |author-first2=Mark S. |author-last2=Johnstone |author-first3=Michael |author-last3=Neely |author-first4=David |author-last4=Boles |date=1995 |edition=1 |title=Dynamic Storage Allocation: A Survey and Critical Review |journal=[[Proceedings of the International Workshop on Memory Management]] (IWMM 95) |volume=986 |pages=1–116 |citeseerx=10.1.1.47.275 |doi=10.1007/3-540-60368-9_19|series=Lecture Notes in Computer Science |isbn=978-3-540-60368-9}}

== External links ==
{{Wikibooks | Memory Management | Garbage Collection}}

* [http://www.memorymanagement.org/ The Memory Management Reference]
* [http://basen.oru.se/kurser/koi/2008-2009-p1/texter/gc/index.html The Very Basics of Garbage Collection]
* [http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html Java SE 6 HotSpot™ Virtual Machine Garbage Collection Tuning]
* [http://tinygc.sourceforge.net/ TinyGC - an independent implementation of the BoehmGC API]
* [http://www.codeproject.com/KB/cpp/conservative_gc.aspx Conservative Garbage Collection Implementation for C Language]
* [http://sourceforge.net/projects/meixnergc/ MeixnerGC - an incremental mark and sweep garbage collector for C++ using smart pointers]

{{Memory management navbox}}
{{John McCarthy navbox}}
{{Authority control}}

[[Category:Memory management]]
[[Category:Automatic memory management|*]]
[[Category:Articles with example code]]
[[Category:Solid-state computer storage]]</text>
      <sha1>qoowrl6u8wtfjkrr7v35ks52wftfr32</sha1>
    </revision>
  </page>
