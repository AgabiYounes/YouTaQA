  <page>
    <title>Erlang (programming language)</title>
    <ns>0</ns>
    <id>9646</id>
    <revision>
      <id>941257264</id>
      <parentid>938693490</parentid>
      <timestamp>2020-02-17T14:25:11Z</timestamp>
      <contributor>
        <ip>188.122.33.11</ip>
      </contributor>
      <comment>/* Functional programming examples */ Relabelled algorithm that produces Fibonacci numbers. It was previously labelled &quot;Factorial&quot;, which from reading the code is glaringly incorrect.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve">{{short description|Programming language}}
{{Infobox programming language
| name = Erlang
| logo = Erlang logo.svg
| paradigms = [[Multi-paradigm programming language|Multi-paradigm]]: [[Concurrent programming|concurrent]], [[Functional programming|functional]]
| family = 
| designer = {{unbulleted list|[[Joe Armstrong (programmer)|Joe Armstrong]]|Robert Virding|Mike Williams}}
| developer = [[Ericsson]]
| released = {{Start date and age|1986}}
| latest release version = 22.2.4&lt;ref&gt;{{cite web |url=https://github.com/erlang/otp/releases |title=Releases - erlang/otp|via=[[GitHub]] |access-date=27 January 2020}}&lt;/ref&gt;
| latest release date = {{Start date and age|2020|01|27|df=yes}}
| typing = [[type system|Dynamic]], [[strong typing|strong]]
| scope = 
| implementations = Erlang
| dialects = 
| influenced_by = [[Lisp (programming language)|Lisp]], [[PLEX (programming language)|PLEX]],&lt;ref&gt;{{cite web |url=https://vimeo.com/97329186 |title=Joe Armstrong - Functional Programming the Long Road to Enlightenment: a Historical and Personal Narrative |first=N. D. C. |last=Conferences |date=4 June 2014 |publisher=Vimeo}}&lt;/ref&gt; [[Prolog]], [[Smalltalk]]
| influenced = [[Akka (toolkit)|Akka]], [[Clojure]]{{Citation needed |date=January 2018}}, [[Dart (programming language)|Dart]], [[Elixir (programming language)|Elixir]], [[F Sharp (programming language)|F#]], [[Opa (programming language)|Opa]], [[Oz (programming language)|Oz]], [[Reia (programming language)|Reia]], [[Rust (programming language)|Rust]], [[Scala (programming language)|Scala]]
| file ext = .erl, .hrl
| license = [[Apache License 2.0]]
| website = {{URL|www.erlang.org}}
| wikibooks = Erlang Programming
}}

'''Erlang''' ({{IPAc-en|ˈ|ɜr|l|æ|ŋ}} {{respell|UR|lang}}) is a [[General-purpose programming language|general-purpose]], [[concurrent computing|concurrent]], [[Functional programming|functional]] [[programming language]], and a [[Garbage collection (computer science)|garbage-collected]] [[runtime system]]. The term Erlang is used interchangeably with Erlang/OTP, or [[Open Telecom Platform]] (OTP), which consists of the Erlang [[runtime system]], several ready-to-use components (OTP) mainly written in Erlang, and a set of [[Systems architecture|design principles]] for Erlang programs.&lt;ref&gt;{{cite web |url=http://erlang.org/doc/system_architecture_intro/sys_arch_intro.html#id58791 |title=Erlang – Introduction |website=erlang.org}}&lt;/ref&gt;

The Erlang [[runtime system]] is designed for systems with these traits:

*[[Distributed computing|Distributed]]
*[[Fault tolerance|Fault-tolerant]]
*[[Soft real-time]]
*[[High availability|Highly available]], [[Uptime|non-stop]] applications
*[[Hot swapping#Software|Hot swapping]], where code can be changed without stopping a system.&lt;ref&gt;{{cite web |last=Armstrong |first=Joe |last2=Däcker |first2=Bjarne |last3=Lindgren |first3=Thomas |last4=Millroth |first4=Håkan |title=Open-source Erlang – White Paper |url=http://ftp.sunet.se/pub/lang/erlang/white_paper.html|archive-url=https://web.archive.org/web/20111025022940/http://ftp.sunet.se/pub/lang/erlang/white_paper.html |archive-date=25 October 2011 |access-date=31 July 2011}}&lt;/ref&gt;

The Erlang [[programming language]] has [[Immutable object|immutable]] data, [[pattern matching]], and [[functional programming]].&lt;ref&gt;Hitchhiker’s Tour of the BEAM – Robert Virding http://www.erlang-factory.com/upload/presentations/708/HitchhikersTouroftheBEAM.pdf&lt;/ref&gt; The sequential subset of the Erlang language supports [[eager evaluation]], [[single assignment]], and [[dynamic typing]].

It was originally [[proprietary software]] within [[Ericsson]], developed by [[Joe Armstrong (programmer)|Joe Armstrong]], Robert Virding, and Mike Williams in 1986,&lt;ref name=&quot;hopl&quot;&gt;{{cite conference |last=Armstrong |first=Joe |title=History of Erlang |work=HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages |date=2007 |isbn=978-1-59593-766-7}}&lt;/ref&gt; but was released as [[free and open-source software]] in 1998.&lt;ref&gt;{{cite web |url=http://www.cio.com/article/3020454/open-source-tools/how-tech-giants-spread-open-source-programming-love.html |title=How tech giants spread open source programming love - CIO.com}}&lt;/ref&gt;&lt;ref&gt;{{cite web |url=http://www.erlang.se/onlinenews/ErlangOTPos.shtml|archive-url=https://web.archive.org/web/19991009002753/http://www.erlang.se/onlinenews/ErlangOTPos.shtml|url-status=dead|archive-date=9 October 1999 |title=Erlang/OTP Released as Open Source, 1998-12-08}}&lt;/ref&gt; Erlang/OTP is supported and maintained by the Open Telecom Platform (OTP) product unit at [[Ericsson]].

==History==
The name ''Erlang'', attributed to Bjarne Däcker, has been presumed by those working on the telephony switches (for whom the language was designed) to be a reference to Danish mathematician and engineer [[Agner Krarup Erlang]] and a [[syllabic abbreviation]] of &quot;Ericsson Language&quot;.&lt;ref name=&quot;hopl&quot;/&gt;&lt;ref&gt;{{cite web |url=http://www.erlang.org/pipermail/erlang-questions/1999-February/000098.html |title=Erlang, the mathematician? |publisher=}}&lt;/ref&gt;{{clarify|and is it?|date=November 2019}} Erlang was designed with the aim of improving the development of telephony applications. The initial version of Erlang was implemented in [[Prolog]] and was influenced by the programming language [[PLEX (programming language)|PLEX]] used in earlier Ericsson exchanges. By 1988 Erlang had proven that it was suitable for prototyping telephone exchanges, but the Prolog interpreter was far too slow. One group within Ericsson estimated that it would need to be 40 times faster to be suitable for production use. In 1992, work began on the [[BEAM (Erlang virtual machine)|BEAM]] virtual machine (VM) which compiles Erlang to C using a mix of natively compiled code and [[threaded code]] to strike a balance between performance and disk space.&lt;ref&gt;{{cite journal |last=Armstrong |first=Joe |title=The development of Erlang |journal=ACM SIGPLAN Notices |date=August 1997 |volume=32 |issue=8 |pages=196–203 |doi=10.1145/258948.258967 |isbn=0897919181 }}&lt;/ref&gt; According to Armstrong, the language went from lab product to real applications following the collapse of the next-generation [[AXE telephone exchange]] named [[:sv:AXE-N|''AXE-N'']] in 1995. As a result, Erlang was chosen for the next [[asynchronous transfer mode]] (ATM) exchange ''AXD''.&lt;ref name=&quot;hopl&quot;/&gt;

In 1998 Ericsson announced the AXD301 switch, containing over a million lines of Erlang and reported to achieve a [[high availability]] of [[nines (engineering)|nine &quot;9&quot;s]].&lt;ref&gt;
{{cite web |url=http://www.rabbitmq.com/resources/armstrong.pdf |title=Concurrency Oriented Programming in Erlang |date=9 November 2002}}
&lt;/ref&gt; Shortly thereafter, Ericsson Radio Systems banned the in-house use of Erlang for new products, citing a preference for non-proprietary languages. The ban caused Armstrong and others to leave Ericsson.&lt;ref name=&quot;questions&quot;/&gt; The implementation was open-sourced at the end of the year.&lt;ref name=&quot;hopl&quot;/&gt; Ericsson eventually lifted the ban and re-hired Armstrong in 2004.&lt;ref name=&quot;questions&quot;&gt;{{cite web |url=http://erlang.org/pipermail/erlang-questions/2006-July/021368.html |title=question about Erlang's future |date=6 July 2010}}&lt;/ref&gt;

In 2006, native [[symmetric multiprocessing]] support was added to the runtime system and VM.&lt;ref name=&quot;hopl&quot;/&gt;

===Processes===
Joe Armstrong, co-inventor of Erlang, summarized the principles of processes in his [[Doctor of Philosophy|PhD]] [[thesis]]:&lt;ref&gt;http://erlang.org/download/armstrong_thesis_2003.pdf&lt;/ref&gt;

*Everything is a process.
*Processes are strongly isolated.
*Process creation and destruction is a lightweight operation.
*Message passing is the only way for processes to interact.
*Processes have unique names.
*If you know the name of a process you can send it a message.
*Processes share no resources.
*Error handling is non-local.
*Processes do what they are supposed to do or fail.

Joe Armstrong remarked in an interview with Rackspace in 2013: “If [[Java (programming language)|Java]] is '[[write once, run anywhere]]', then Erlang is 'write once, run forever'.”&lt;ref&gt;{{cite AV media |last=McGreggor |first=Duncan |date=26 March 2013 |title=Rackspace takes a look at the Erlang programming language for distributed computing |medium=Video |language=English |url=https://www.youtube.com/watch?v=u41GEwIq2mE&amp;t=3m59s |format= |location= |publisher=Rackspace Studios, SFO |id= |isbn= |oclc= |access-date=24 April 2019}}&lt;/ref&gt;

===Usage===
In 2014, [[Ericsson]] reported Erlang was being used in its support nodes, and in [[GPRS]], [[3G]] and [[LTE (telecommunication)|LTE]] mobile networks worldwide and also by [[Nortel]] and [[T-Mobile]].&lt;ref&gt;{{cite web |url=http://www.ericsson.com/news/141204-inside-erlang-creator-joe-armstrong-tells-his-story_244099435_c |title=Ericsson |work=Ericsson.com |date=4 December 2014 |access-date=7 April 2018}}&lt;/ref&gt;

As [[Tim Bray]], director of Web Technologies at [[Sun Microsystems]], expressed in his keynote at [[O'Reilly Open Source Convention]] (OSCON) in July 2008:
{{quote|If somebody came to me and wanted to pay me a lot of money to build a large scale message handling system that really had to be up all the time, could never afford to go down for years at a time, I would unhesitatingly choose Erlang to build it in.}}

Erlang is the programming language used to code [[WhatsApp]].&lt;ref&gt;{{cite web |url=https://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success |title=Inside Erlang, The Rare Programming Language Behind WhatsApp's Success |work=fastcompany.com |date=21 February 2014 |access-date=12 November 2019}}&lt;/ref&gt;

==Functional programming examples==

===Factorial===
A [[factorial]] algorithm implemented in Erlang:
&lt;source lang=&quot;erlang&quot;&gt;
-module(fact). % This is the file 'fact.erl', the module and the filename must match
-export([fac/1]). % This exports the function 'fac' of arity 1 (1 parameter, no type, no name)

fac(0) -&gt; 1; % If 0, then return 1, otherwise (note the semicolon ; meaning 'else')
fac(N) when N &gt; 0, is_integer(N) -&gt; N * fac(N-1).
% Recursively determine, then return the result
% (note the period . meaning 'endif' or 'function end')
%% This function will crash if anything other than a nonnegative integer is given.
%% It illustrates the &quot;Let it crash&quot; philosophy of Erlang.
&lt;/source&gt;

===Fibonacci sequence===

A tail recursive algorithm that produces the [[Fibonacci sequence]]:

&lt;source lang=&quot;erlang&quot;&gt;
%% The module declaration must match the file name &quot;series.erl&quot; 
-module(series).

%% The export statement contains a list of all those functions that form
%% the module's public API.  In this case, this module exposes a single
%% function called fib that takes 1 argument (I.E. has an arity of 1)
%% The general syntax for -export is a list containing the name and
%% arity of each public function
-export([fib/1]).

%% ---------------------------------------------------------------------
%% Public API
%% ---------------------------------------------------------------------

%% Handle cases in which fib/1 receives specific values
%% The order in which these function signatures are declared is a vital
%% part of this module's functionality

%% If fib/1 is passed precisely the integer 0, then return 0
fib(0) -&gt; 0;

%% If fib/1 receives a negative number, then return the atom err_neg_val
%% Normally, such defensive coding is discouraged due to Erlang's 'Let
%% it Crash' philosophy; however, in this case we should explicitly
%% prevent a situation that will crash Erlang's runtime engine
fib(N) when N &lt; 0 -&gt; err_neg_val;

%% If fib/1 is passed an integer less than 3, then return 1
%% The preceding two function signatures handle all cases where N &lt; 1,
%% so this function signature handles cases where N = 1 or N = 2
fib(N) when N &lt; 3 -&gt; 1;

%% For all other values, call the private function fib_int/3 to perform
%% the calculation
fib(N) -&gt; fib_int(N, 0, 1).


%% ---------------------------------------------------------------------
%% Private API
%% ---------------------------------------------------------------------

%% If fib_int/3 receives a 1 as its first argument, then we're done, so
%% return the value in argument B.  Since we are not interested in the
%% value of the second argument, we denote this using _ to indicate a
%% &quot;don't care&quot; value
fib_int(1, _, B) -&gt; B;

%% For all other argument combinations, recursively call fib_int/3
%% where each call does the following:
%%  - decrement counter N
%%  - Take the previous fibonacci value in argument B and pass it as
%%    argument A
%%  - Calculate the value of the current fibonacci number and pass it
%%    as argument B
fib_int(N, A, B) -&gt; fib_int(N-1, B, A+B).
&lt;/source&gt;

Here's the same program without the explanatory comments:

&lt;source lang=&quot;erlang&quot;&gt;
-module(series).
-export([fib/1]).

fib(0) -&gt; 0;
fib(N) when N &lt; 0 -&gt; err_neg_val;
fib(N) when N &lt; 3 -&gt; 1;
fib(N) -&gt; fib_int(N, 0, 1).

fib_int(1, _, B) -&gt; B;
fib_int(N, A, B) -&gt; fib_int(N-1, B, A+B).
&lt;/source&gt;

===Quicksort===
[[Quicksort]] in Erlang, using [[list comprehension]]:&lt;ref&gt;{{cite web |url=http://erlang.org/doc/programming_examples/list_comprehensions.html |title=Erlang – List Comprehensions |website=erlang.org}}&lt;/ref&gt;

&lt;source lang=&quot;erlang&quot;&gt;
%% qsort:qsort(List)
%% Sort a list of items
-module(qsort).     % This is the file 'qsort.erl'
-export([qsort/1]). % A function 'qsort' with 1 parameter is exported (no type, no name)

qsort([]) -&gt; []; % If the list [] is empty, return an empty list (nothing to sort)
qsort([Pivot|Rest]) -&gt;
    % Compose recursively a list with 'Front' for all elements that should be before 'Pivot'
    % then 'Pivot' then 'Back' for all elements that should be after 'Pivot'
    qsort([Front || Front &lt;- Rest, Front &lt; Pivot]) ++ 
    [Pivot] ++
    qsort([Back || Back &lt;- Rest, Back &gt;= Pivot]).
&lt;/source&gt;

The above example recursively invokes the function &lt;code&gt;qsort&lt;/code&gt; until nothing remains to be sorted. The expression &lt;code&gt;[Front || Front &lt;- Rest, Front &lt; Pivot]&lt;/code&gt; is a [[list comprehension]], meaning &quot;Construct a list of elements &lt;code&gt;Front&lt;/code&gt; such that &lt;code&gt;Front&lt;/code&gt; is a member of &lt;code&gt;Rest&lt;/code&gt;, and &lt;code&gt;Front&lt;/code&gt; is less than &lt;code&gt;Pivot&lt;/code&gt;.&quot; &lt;code&gt;++&lt;/code&gt; is the list concatenation operator.

A comparison function can be used for more complicated structures for the sake of readability.

The following code would sort lists according to length:
&lt;source lang=&quot;erlang&quot;&gt;
% This is file 'listsort.erl' (the compiler is made this way)
-module(listsort).
% Export 'by_length' with 1 parameter (don't care about the type and name)
-export([by_length/1]).

by_length(Lists) -&gt; % Use 'qsort/2' and provides an anonymous function as a parameter
   qsort(Lists, fun(A,B) -&gt; length(A) &lt; length(B) end).

qsort([], _)-&gt; []; % If list is empty, return an empty list (ignore the second parameter)
qsort([Pivot|Rest], Smaller) -&gt;
    % Partition list with 'Smaller' elements in front of 'Pivot' and not-'Smaller' elements
    % after 'Pivot' and sort the sublists.
    qsort([X || X &lt;- Rest, Smaller(X,Pivot)], Smaller)
    ++ [Pivot] ++
    qsort([Y || Y &lt;- Rest, not(Smaller(Y, Pivot))], Smaller).
&lt;/source&gt;

A &lt;code&gt;Pivot&lt;/code&gt; is taken from the first parameter given to &lt;code&gt;qsort()&lt;/code&gt; and the rest of &lt;code&gt;Lists&lt;/code&gt; is named &lt;code&gt;Rest&lt;/code&gt;. Note that the expression

&lt;source lang=&quot;erlang&quot;&gt;[X || X &lt;- Rest, Smaller(X,Pivot)]&lt;/source&gt;

is no different in form from

&lt;source lang=&quot;erlang&quot;&gt;[Front || Front &lt;- Rest, Front &lt; Pivot]&lt;/source&gt;

(in the previous example) except for the use of a comparison function in the last part, saying &quot;Construct a list of elements &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;X&lt;/code&gt; is a member of &lt;code&gt;Rest&lt;/code&gt;, and &lt;code&gt;Smaller&lt;/code&gt; is true&quot;, with &lt;code&gt;Smaller&lt;/code&gt; being defined earlier as

&lt;source lang=&quot;erlang&quot;&gt;fun(A,B) -&gt; length(A) &lt; length(B) end&lt;/source&gt;

The [[anonymous function]] is named &lt;code&gt;Smaller&lt;/code&gt; in the parameter list of the second definition of &lt;code&gt;qsort&lt;/code&gt; so that it can be referenced by that name within that function. It is not named in the first definition of &lt;code&gt;qsort&lt;/code&gt;, which deals with the base case of an empty list and thus has no need of this function, let alone a name for it.

==Data types==
Erlang has eight primitive [[data type]]s:

;Integers: Integers are written as sequences of decimal digits, for example, 12, 12375 and -23427 are integers. Integer arithmetic is exact and only limited by available memory on the machine. (This is called [[arbitrary-precision arithmetic]].)
;Atoms: Atoms are used within a program to denote distinguished values. They are written as strings of consecutive alphanumeric characters, the first character being lowercase. Atoms can contain any character if they are enclosed within single quotes and an escape convention exists which allows any character to be used within an atom. Atoms are never garbage collected and should be used with caution, especially if using dynamic atom generation.
;Floats: Floating point numbers use the [[binary64|IEEE 754 64-bit representation]].
;References: References are globally unique symbols whose only property is that they can be compared for equality. They are created by evaluating the Erlang primitive &lt;code&gt;make_ref()&lt;/code&gt;.
;Binaries: A binary is a sequence of bytes. Binaries provide a space-efficient way of storing binary data. Erlang primitives exist for composing and decomposing binaries and for efficient input/output of binaries.
;Pids: Pid is short for ''process identifier''{{snd}}a Pid is created by the Erlang primitive &lt;code&gt;spawn(...)&lt;/code&gt; Pids are references to Erlang processes.
;Ports: Ports are used to communicate with the external world. Ports are created with the built-in function &lt;code&gt;open_port&lt;/code&gt;. Messages can be sent to and received from ports, but these messages must obey the so-called &quot;port protocol.&quot;
;Funs: Funs are function [[Closure (computer programming)|closures]]. Funs are created by expressions of the form: &lt;code&gt;fun(...) -&gt; ... end&lt;/code&gt;.

And three compound data types:

;Tuples: Tuples are containers for a fixed number of Erlang data types. The syntax &lt;code&gt;{D1,D2,...,Dn}&lt;/code&gt; denotes a tuple whose arguments are &lt;code&gt;D1, D2, ... Dn.&lt;/code&gt; The arguments can be primitive data types or compound data types. Any element of a tuple can be accessed in constant time.
;Lists: Lists are containers for a variable number of Erlang data types. The syntax &lt;code&gt;[Dh|Dt]&lt;/code&gt; denotes a list whose first element is &lt;code&gt;Dh&lt;/code&gt;, and whose remaining elements are the list &lt;code&gt;Dt&lt;/code&gt;. The syntax &lt;code&gt;[]&lt;/code&gt; denotes an empty list. The syntax &lt;code&gt;[D1,D2,..,Dn]&lt;/code&gt; is short for &lt;code&gt;[D1|[D2|..|[Dn|[]]]]&lt;/code&gt;. The first element of a list can be accessed in constant time. The first element of a list is called the ''head'' of the list. The remainder of a list when its head has been removed is called the ''tail'' of the list.
;Maps: Maps contain a variable number of key-value associations. The syntax is&lt;code&gt;#{Key1=&gt;Value1,...,KeyN=&gt;ValueN}&lt;/code&gt;.

Two forms of [[syntactic sugar]] are provided:

;Strings: Strings are written as doubly quoted lists of characters. This is syntactic sugar for a list of the integer [[Unicode]] code points for the characters in the string. Thus, for example, the string &quot;cat&quot; is shorthand for &lt;code&gt;[99,97,116]&lt;/code&gt;.&lt;ref&gt;{{cite web |url=http://erlang.org/doc/apps/stdlib/unicode_usage.html#string-and-character-literals |title=String and Character Literals |publisher= |access-date=2 May 2015}}&lt;/ref&gt;
;Records: Records provide a convenient way for associating a tag with each of the elements in a tuple. This allows one to refer to an element of a tuple by name and not by position. A pre-compiler takes the record definition and replaces it with the appropriate tuple reference.

Erlang has no method to define classes, although there are external [[Library (computing)|libraries]] available.&lt;ref&gt;{{cite web |url=https://code.google.com/p/ect/ |title=ect – Erlang Class Transformation – add object-oriented programming to Erlang – Google Project Hosting |publisher= |access-date=2 May 2015}}&lt;/ref&gt;

==&quot;Let it Crash&quot; coding style==
In most other programming languages, software crashes have always been (and often still are) considered highly undesirable situations that must be avoided at all costs.  Consequently, elaborate exception handling mechanisms exist to trap these situations and then mitigate their effects. This design philosophy exists because many of the foundational principles of software design were defined at a time when computers were single processor machines.  Under these conditions, software crashes were indeed fatal.  Given this basic constraint, it was perfectly natural therefore to develop programming styles in which a large proportion of the code was dedicated to detecting and then handling error situations.  This in turn, led directly to the still widely popular coding style known as [[defensive programming]].

However, the designers of Erlang realised that in spite of their undesirable effects, software crashes are much like death and taxes - quite unavoidable.  Therefore, rather than treating a crash as a crisis situation that temporarily suspends all normal work until a solution is found, they reasoned it would make far greater sense to treat a crash in exactly the same manner as any other normal runtime event.  Consequently, when an Erlang process crashes, this situation is reported as just another type of message arriving in a process' mail box.

This realisation led to Erlang's designers building a language with the following fundamental features:

*Erlang has no concept of global memory; therefore relative to each other, all processes are isolated execution environments
*Erlang processes can:
**be spawned very cheaply
**only communicate using message passing
**monitor each other. This allows processes to be arranged in hierarchies known as &quot;supervisor trees.&quot;
*A process should perform its task or fail
*Process failure is reported simply as a message

The &quot;Let it Crash&quot; style of coding is therefore the practical consequence of working in a language that operates on these principles.

===Supervisor trees===
A typical Erlang application is written in the form of a supervisor tree.  This architecture is based on a hierarchy of processes in which the top level process is known as a &quot;supervisor&quot;.  The supervisor then spawns multiple child processes that act either as workers or more, lower level supervisors.  Such hierarchies can exist to arbitrary depths and have proven to provide a highly scalable and fault-tolerant environment within which application functionality can be implemented.

Within a supervisor tree, all supervisor processes are responsible for managing the lifecycle of their child processes, and this includes handling situations in which those child processes crash.  Any process can become a supervisor by first spawning a child process, then calling &lt;code&gt;erlang:monitor/2&lt;/code&gt; on that process.  If the monitored process then crashes, the supervisor will receive a message containing a tuple whose first member is the atom &lt;code&gt;'DOWN'&lt;/code&gt;.  The supervisor is responsible firstly for listening for such messages and secondly, for taking the appropriate action to correct the error condition.

In addition, &quot;Let it Crash&quot; results in a style of coding that contains little defensive code, resulting in smaller applications.

==Concurrency and distribution orientation==
Erlang's main strength is support for [[Concurrency (computer science)|concurrency]]. It has a small but powerful set of primitives to create processes and communicate among them. Erlang is conceptually similar to the language [[occam (programming language)|occam]], though it recasts the ideas of [[communicating sequential processes]] (CSP) in a functional framework and uses asynchronous message passing.&lt;ref&gt;{{cite journal
 |title=Erlang
 |journal=[[Communications of the ACM]]
 |volume=53 |issue=9
 |date=September 2010 
 |pages=68–75
 |doi=10.1145/1810891.1810910
 |first=Joe |last=Armstrong 
 |authorlink=Joe Armstrong (programmer)
 |quote=Erlang is conceptually similar to the occam programming language, though it recasts the ideas of CSP in a functional framework and uses asynchronous message passing.
}}&lt;/ref&gt; Processes are the primary means to structure an Erlang application. They are neither [[operating system]] [[Process (computing)|processes]] nor [[Thread (computing)|threads]], but lightweight processes that are scheduled by BEAM. Like operating system processes (but unlike operating system threads), they share no state with each other. The estimated minimal overhead for each is 300 [[Word (computer architecture)|words]].&lt;ref&gt;{{cite web |title=Erlang Efficiency Guide – Processes |url=http://www.erlang.org/doc/efficiency_guide/processes.html|archive-url=https://web.archive.org/web/20150227174813/http://www.erlang.org/doc/efficiency_guide/processes.html|archive-date=27 February 2015}}&lt;/ref&gt; Thus, many processes can be created without degrading performance. In 2005, a benchmark with 20 million processes was successfully performed with 64-bit Erlang on a machine with 16 GB [[random-access memory]] (RAM; total 800 bytes/process).&lt;ref&gt;{{cite web |first=Ulf |last=Wiger |title=Stress-testing erlang |url=https://groups.google.com/group/comp.lang.functional/msg/33b7a62afb727a4f?dmode=source |work=comp.lang.functional.misc |access-date=25 August 2006 |date=14 November 2005}}&lt;/ref&gt; Erlang has supported [[symmetric multiprocessing]] since release R11B of May 2006.

While [[Thread (computing)|threads]] need external library support in most languages, Erlang provides language-level features to create and manage processes with the goal of simplifying concurrent programming. Though all concurrency is explicit in Erlang, processes communicate using [[message passing]] instead of shared variables, which removes the need for explicit [[Lock (computer science)|locks]] (a locking scheme is still used internally by the VM).&lt;ref&gt;{{cite web |title=Lock-free message queue |url=http://erlang.2086793.n4.nabble.com/Lock-free-message-queue-td2550221.html |access-date=23 December 2013}}&lt;/ref&gt;

[[Inter-process communication]] works via a [[Shared nothing architecture|shared-nothing]] [[asynchronous method dispatch|asynchronous]] [[message passing]] system: every process has a &quot;mailbox&quot;, a [[queue (data structure)|queue]] of messages that have been sent by other processes and not yet consumed. A process uses the &lt;code&gt;receive&lt;/code&gt; primitive to retrieve messages that match desired patterns. A message-handling routine tests messages in turn against each pattern, until one of them matches. When the message is consumed and removed from the mailbox the process resumes execution. A message may comprise any Erlang structure, including primitives (integers, floats, characters, atoms), tuples, lists, and functions.

The code example below shows the built-in support for distributed processes:

&lt;source lang=&quot;erlang&quot;&gt;
 % Create a process and invoke the function web:start_server(Port, MaxConnections)
 ServerProcess = spawn(web, start_server, [Port, MaxConnections]),

 % Create a remote process and invoke the function
 % web:start_server(Port, MaxConnections) on machine RemoteNode
 RemoteProcess = spawn(RemoteNode, web, start_server, [Port, MaxConnections]),

 % Send a message to ServerProcess (asynchronously). The message consists of a tuple
 % with the atom &quot;pause&quot; and the number &quot;10&quot;.
 ServerProcess ! {pause, 10},

 % Receive messages sent to this process
 receive
         a_message -&gt; do_something;
         {data, DataContent} -&gt; handle(DataContent);
         {hello, Text} -&gt; io:format(&quot;Got hello message: ~s&quot;, [Text]);
         {goodbye, Text} -&gt; io:format(&quot;Got goodbye message: ~s&quot;, [Text])
 end.
&lt;/source&gt;

As the example shows, processes may be created on remote nodes, and communication with them is transparent in the sense that communication with remote processes works exactly as communication with local processes.

Concurrency supports the primary method of error-handling in Erlang. When a process crashes, it neatly exits and sends a message to the controlling process which can then take action, such as for instance starting a new process that takes over the old process's task.&lt;ref&gt;{{cite web |first=Joe |last=Armstrong |title=Erlang robustness |url=http://www.erlang.org/doc/getting_started/robustness.html|archive-url=https://web.archive.org/web/20150423182840/http://www.erlang.org/doc/getting_started/robustness.html|archive-date=23 April 2015 |access-date=15 July 2010}}&lt;/ref&gt;&lt;ref&gt;{{cite web |title=Erlang Supervision principles |url=http://www.erlang.org/doc/design_principles/sup_princ.html|archive-url=https://web.archive.org/web/20150206050600/http://www.erlang.org/doc/design_principles/sup_princ.html|archive-date=6 February 2015 |access-date=15 July 2010}}&lt;/ref&gt;

==Implementation==
The official reference implementation of Erlang uses BEAM.&lt;ref&gt;{{cite web |url=http://erlang.org/doc/reference_manual/code_loading.html#id90080 |title=Erlang – Compilation and Code Loading |website=erlang.org |access-date=2017-12-21}}&lt;/ref&gt; BEAM is included in the official distribution of Erlang, called Erlang/OTP. BEAM executes [[bytecode]] which is converted to [[threaded code]] at load time. It also includes a native code compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at [[Uppsala University]]. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system.&lt;ref&gt;{{cite web |title=High Performance Erlang |url=http://www.it.uu.se/research/group/hipe/ |access-date=26 March 2011}}&lt;/ref&gt; It also supports interpreting, directly from source code via [[abstract syntax tree]], via script as of R11B-5 release of Erlang.

==Hot code loading and modules==
Erlang supports language-level [[Dynamic Software Updating]]. To implement this, code is loaded and managed as &quot;module&quot; units; the module is a [[compilation unit]]. The system can keep two versions of a module in memory at the same time, and processes can concurrently run code from each. The versions are referred to as the &quot;new&quot; and the &quot;old&quot; version. A process will not move into the new version until it makes an external call to its module.

An example of the mechanism of hot code loading:

&lt;source lang = &quot;erlang&quot;&gt;
  %% A process whose only job is to keep a counter.
  %% First version
  -module(counter).
  -export([start/0, codeswitch/1]).

  start() -&gt; loop(0).

  loop(Sum) -&gt;
    receive
       {increment, Count} -&gt;
          loop(Sum+Count);
       {counter, Pid} -&gt;
          Pid ! {counter, Sum},
          loop(Sum);
       code_switch -&gt;
          ?MODULE:codeswitch(Sum)
          % Force the use of 'codeswitch/1' from the latest MODULE version
    end.

  codeswitch(Sum) -&gt; loop(Sum).
&lt;/source&gt;

For the second version, we add the possibility to reset the count to zero.

&lt;source lang = &quot;erlang&quot;&gt;
  %% Second version
  -module(counter).
  -export([start/0, codeswitch/1]).

  start() -&gt; loop(0).

  loop(Sum) -&gt;
    receive
       {increment, Count} -&gt;
          loop(Sum+Count);
       reset -&gt;
          loop(0);
       {counter, Pid} -&gt;
          Pid ! {counter, Sum},
          loop(Sum);
       code_switch -&gt;
          ?MODULE:codeswitch(Sum)
    end.

  codeswitch(Sum) -&gt; loop(Sum).
&lt;/source&gt;

Only when receiving a message consisting of the atom &lt;code&gt;code_switch&lt;/code&gt; will the loop execute an external call to codeswitch/1 (&lt;code&gt;?MODULE&lt;/code&gt; is a preprocessor macro for the current module). If there is a new version of the ''counter'' module in memory, then its codeswitch/1 function will be called. The practice of having a specific entry-point into a new version allows the programmer to transform state to what is needed in the newer version. In the example, the state is kept as an integer.

In practice, systems are built up using design principles from the Open Telecom Platform, which leads to more code upgradable designs. Successful hot code loading is exacting. Code must be written with care to make use of Erlang's facilities.

==Distribution==
In 1998, Ericsson released Erlang as [[free and open-source software]] to ensure its independence from a single vendor and to increase awareness of the language. Erlang, together with libraries and the real-time distributed database [[Mnesia]], forms the OTP collection of libraries. Ericsson and a few other companies support Erlang commercially.

Since the open source release, Erlang has been used by several firms worldwide, including [[Nortel Networks|Nortel]] and [[T-Mobile]].&lt;ref&gt;{{cite web |title=Who uses Erlang for product development? |work=Frequently asked questions about Erlang |url=http://erlang.org/faq/introduction.html#idp32141008 |access-date=16 July 2007 |quote=''The largest user of Erlang is (surprise!) Ericsson. Ericsson use it to write software used in telecommunications systems. Many dozens of projects have used it, a particularly large one is the extremely scalable AXD301 ATM switch.'' Other commercial users listed as part of the FAQ include: Nortel, Deutsche Flugsicherung (the German national [[air traffic control]] organisation), and T-Mobile.}}&lt;/ref&gt; Although Erlang was designed to fill a niche and has remained an obscure language for most of its existence, its popularity is growing due to demand for concurrent services.&lt;ref&gt;{{cite web |title=Programming Erlang |url=http://www.ddj.com/linux-open-source/201001928?cid=RSSfeed_DDJ_OpenSource |access-date=13 December 2008 |quote=Virtually all language use shared state concurrency. This is very difficult and leads to terrible problems when you handle failure and scale up the system...Some pretty fast-moving startups in the financial world have latched onto Erlang; for example, the Swedish www.kreditor.se.}}&lt;/ref&gt;&lt;ref&gt;{{cite web |title=Erlang, the next Java |url=http://www.cincomsmalltalk.com/userblogs/ralph/blogView?showComments=true&amp;entry=3364027251|archive-url=https://web.archive.org/web/20071011065959/http://cincomsmalltalk.com/userblogs/ralph/blogView?showComments=true&amp;entry=3364027251|url-status=dead|archive-date=11 October 2007 |access-date=8 October 2008 |quote=I do not believe that other languages can catch up with Erlang anytime soon. It will be easy for them to add language features to be like Erlang. It will take a long time for them to build such a high-quality VM and the mature libraries for concurrency and reliability. So, Erlang is poised for success. If you want to build a multicore application in the next few years, you should look at Erlang.}}&lt;/ref&gt;
Erlang has found some use in fielding [[massively multiplayer online role-playing game]] (MMORPG) servers.&lt;ref&gt;{{cite web
 |last=Clarke
 |first=Gavin
 |title=Battlestar Galactica vets needed for online roleplay
 |work=Music and Media
 |publisher=[[The Reg]]
 |date=5 February 2011
 |url=https://www.theregister.co.uk/2011/02/05/battlestar_galactica_mmp/
 |doi=
 |access-date=8 February 2011}}
&lt;/ref&gt;

==See also==
* [[Elixir (programming language)|Elixir]] – a functional, concurrent, general-purpose programming language that runs on BEAM
* [[LFE (programming language)|Lisp Flavored Erlang]] (LFE) – a Lisp-based programming language that runs on BEAM
* [[Mix (build tool)]]
* [[Phoenix (web framework)]]

==References==
{{Reflist|30em}}

==Further reading==
{{Refbegin}}
* {{Cite journal |first=Joe |last=Armstrong |title=Making reliable distributed systems in the presence of software errors |url=https://www.sics.se/~joe/thesis/armstrong_thesis_2003.pdf |version=Ph.D. Dissertation |publisher=The Royal Institute of Technology, Stockholm, Sweden |year=2003 |access-date=13 February 2016 |url-status=bot: unknown |archive-url=https://web.archive.org/web/20150323001245/https://www.sics.se/~joe/thesis/armstrong_thesis_2003.pdf |archive-date=23 March 2015 |df=dmy}}
* {{cite book |doi=10.1145/1238844.1238850 |isbn=978-1-59593-766-7 |title=Proceedings of the third ACM SIGPLAN conference on History of programming languages – HOPL III |year=2007 |chapter=A history of Erlang |last=Armstrong |first=Joe |pages=6–1}}
* [http://www.erlang.se/publications/bjarnelic.pdf Early history of Erlang] by Bjarne Däcker
*{{cite journal |last=Mattsson |first=H. |last2=Nilsson |first2=H. |last3=Wikstrom |first3=C. |year=1999 |title=Mnesia – A distributed robust DBMS for telecommunications applications |journal=First International Workshop on Practical Aspects of Declarative Languages (PADL '99) |pages=152–163}}
* {{cite book
 |first=Joe
 |last=Armstrong
 |first2=Robert
 |last2=Virding
 |first3=Mike
 |last3=Williams
 |first4=Claes
 |last4=Wikstrom
 |title=Concurrent Programming in Erlang
 |publisher=[[Prentice Hall]]
 |edition=2nd
 |date=16 January 1996
 |page=358
 |isbn=978-0-13-508301-7
 |url=http://www.erlang.org/erlang_book_toc.html
 |archive-url=https://web.archive.org/web/20120306002430/http://www.erlang.org/erlang_book_toc.html
 |archive-date=6 March 2012
}}
* {{cite book
 |first=Joe
 |last=Armstrong
 |title=Programming Erlang: Software for a Concurrent World
 |publisher=[[Pragmatic Bookshelf]]
 |edition=1st
 |date=11 July 2007
 |page=[https://archive.org/details/programmingerlan0000arms/page/536 536]
 |isbn=978-1-934356-00-5
 |url=https://archive.org/details/programmingerlan0000arms/page/536
 |url-access=registration
 }}
* {{cite book
 |first=Simon J.
 |last=Thompson
 |first2=Francesco
 |last2=Cesarini
 |title=Erlang Programming: A Concurrent Approach to Software Development
 |publisher=[[O'Reilly Media]], Inc.
 |edition=1st
 |date=19 June 2009
 |page=496
 |location=Sebastopol, California
 |isbn=978-0-596-51818-9
 |url=http://www.erlangprogramming.org
}}
* {{cite book
 |first=Martin
 |last=Logan
 |first2=Eric
 |last2=Merritt
 |first3=Richard
 |last3=Carlsson
 |title=Erlang and OTP in Action
 |publisher=[[Manning Publications]]
 |edition=1st
 |date=28 May 2010
 |page=500
 |location=Greenwich, CT
 |isbn=978-1-933988-78-8
 |url=
}}
* {{cite web
 |last=Martin
 |first=Brown
 |title=Introduction to programming in Erlang, Part 1: The basics
 |work=developerWorks
 |publisher=IBM
 |date=10 May 2011
 |url=http://www.ibm.com/developerworks/opensource/library/os-erlang1/index.html
 |access-date=10 May 2011
}}
* {{cite web
 |last=Martin
 |first=Brown
 |title=Introduction to programming in Erlang, Part 2: Use advanced features and functionality
 |work=developerWorks
 |publisher=IBM
 |date=17 May 2011
 |url=http://www.ibm.com/developerworks/opensource/library/os-erlang2/index.html
 |access-date=17 May 2011}}
* {{cite web
 |last=Wiger
 |first=Ulf
 |title=Four-fold Increase in Productivity and Quality: Industrial-Strength Functional Programming in Telecom-Class Products
 |work=FEmSYS 2001 Deployment on distributed architectures
 |publisher=Ericsson Telecom AB
 |date=30 Mar 2001
 |url=http://www.erlang.se/publications/Ulf_Wiger.pdf
 |access-date=16 September 2014
}}
{{Refend}}

==External links==
{{Commons category}}
{{Wikibooks|Erlang Programming}}
* {{Official website}}
* {{cite web |url=http://www.ericsson.com/news/141204-inside-erlang-creator-joe-armstrong-tells-his-story_244099435_c |title=Inside Erlang – Creator Joe Armstrong Tells His Story |website=Ericsson |date=Dec 4, 2014 |display-authors=0 |first=Joe |last=Armstrong}}

{{use dmy dates |date=January 2012}}

[[Category:Programming languages]]
[[Category:Concurrent programming languages]]
[[Category:Declarative programming languages]]
[[Category:Dynamically typed programming languages]]
[[Category:Ericsson]]
[[Category:Erlang (programming language)| ]]
[[Category:Formerly proprietary software]]
[[Category:Functional languages]]
[[Category:Pattern matching programming languages]]
[[Category:Programming languages created in 1986]]
[[Category:Register-based virtual machines]]
[[Category:Dynamic programming languages]]
[[Category:Cross-platform free software]]</text>
      <sha1>dqr0yazwlqs6tlcy94ezv5k3u7vtg88</sha1>
    </revision>
  </page>
